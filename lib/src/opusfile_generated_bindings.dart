// ignore_for_file: always_specify_types, unused_element, unused_field
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to libopusfile
class OpusfileBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  OpusfileBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  OpusfileBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<Native__va_start>>('__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<Dart__va_start>(isLeaf: true);

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<Native__security_init_cookie>>(
          '__security_init_cookie');
  late final ___security_init_cookie = ___security_init_cookiePtr
      .asFunction<Dart__security_init_cookie>(isLeaf: true);

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<Native__security_check_cookie>>(
          '__security_check_cookie');
  late final ___security_check_cookie = ___security_check_cookiePtr
      .asFunction<Dart__security_check_cookie>(isLeaf: true);

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<Native__report_gsfailure>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<Dart__report_gsfailure>(isLeaf: true);

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<Native_invalid_parameter_noinfo>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo = __invalid_parameter_noinfoPtr
      .asFunction<Dart_invalid_parameter_noinfo>(isLeaf: true);

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<Native_invalid_parameter_noinfo_noreturn>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr
          .asFunction<Dart_invalid_parameter_noinfo_noreturn>(isLeaf: true);

  void _invoke_watson(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr =
      _lookup<ffi.NativeFunction<Native_invoke_watson>>('_invoke_watson');
  late final __invoke_watson =
      __invoke_watsonPtr.asFunction<Dart_invoke_watson>(isLeaf: true);

  ffi.Pointer<FILE> __acrt_iob_func(
    int _Ix,
  ) {
    return ___acrt_iob_func(
      _Ix,
    );
  }

  late final ___acrt_iob_funcPtr =
      _lookup<ffi.NativeFunction<Native__acrt_iob_func>>('__acrt_iob_func');
  late final ___acrt_iob_func =
      ___acrt_iob_funcPtr.asFunction<Dart__acrt_iob_func>(isLeaf: true);

  int fgetwc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetwc(
      _Stream,
    );
  }

  late final _fgetwcPtr = _lookup<ffi.NativeFunction<NativeFgetwc>>('fgetwc');
  late final _fgetwc = _fgetwcPtr.asFunction<DartFgetwc>(isLeaf: true);

  int _fgetwchar() {
    return __fgetwchar();
  }

  late final __fgetwcharPtr =
      _lookup<ffi.NativeFunction<Native_fgetwchar>>('_fgetwchar');
  late final __fgetwchar =
      __fgetwcharPtr.asFunction<Dart_fgetwchar>(isLeaf: true);

  int fputwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputwc(
      _Character,
      _Stream,
    );
  }

  late final _fputwcPtr = _lookup<ffi.NativeFunction<NativeFputwc>>('fputwc');
  late final _fputwc = _fputwcPtr.asFunction<DartFputwc>(isLeaf: true);

  int _fputwchar(
    int _Character,
  ) {
    return __fputwchar(
      _Character,
    );
  }

  late final __fputwcharPtr =
      _lookup<ffi.NativeFunction<Native_fputwchar>>('_fputwchar');
  late final __fputwchar =
      __fputwcharPtr.asFunction<Dart_fputwchar>(isLeaf: true);

  int getwc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getwc(
      _Stream,
    );
  }

  late final _getwcPtr = _lookup<ffi.NativeFunction<NativeGetwc>>('getwc');
  late final _getwc = _getwcPtr.asFunction<DartGetwc>(isLeaf: true);

  int getwchar() {
    return _getwchar();
  }

  late final _getwcharPtr =
      _lookup<ffi.NativeFunction<NativeGetwchar>>('getwchar');
  late final _getwchar = _getwcharPtr.asFunction<DartGetwchar>(isLeaf: true);

  ffi.Pointer<ffi.WChar> fgetws(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetws(
      _Buffer,
      _BufferCount,
      _Stream,
    );
  }

  late final _fgetwsPtr = _lookup<ffi.NativeFunction<NativeFgetws>>('fgetws');
  late final _fgetws = _fgetwsPtr.asFunction<DartFgetws>(isLeaf: true);

  int fputws(
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputws(
      _Buffer,
      _Stream,
    );
  }

  late final _fputwsPtr = _lookup<ffi.NativeFunction<NativeFputws>>('fputws');
  late final _fputws = _fputwsPtr.asFunction<DartFputws>(isLeaf: true);

  ffi.Pointer<ffi.WChar> _getws_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
  ) {
    return __getws_s(
      _Buffer,
      _BufferCount,
    );
  }

  late final __getws_sPtr =
      _lookup<ffi.NativeFunction<Native_getws_s>>('_getws_s');
  late final __getws_s = __getws_sPtr.asFunction<Dart_getws_s>(isLeaf: true);

  int putwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putwc(
      _Character,
      _Stream,
    );
  }

  late final _putwcPtr = _lookup<ffi.NativeFunction<NativePutwc>>('putwc');
  late final _putwc = _putwcPtr.asFunction<DartPutwc>(isLeaf: true);

  int putwchar(
    int _Character,
  ) {
    return _putwchar(
      _Character,
    );
  }

  late final _putwcharPtr =
      _lookup<ffi.NativeFunction<NativePutwchar>>('putwchar');
  late final _putwchar = _putwcharPtr.asFunction<DartPutwchar>(isLeaf: true);

  int _putws(
    ffi.Pointer<ffi.WChar> _Buffer,
  ) {
    return __putws(
      _Buffer,
    );
  }

  late final __putwsPtr = _lookup<ffi.NativeFunction<Native_putws>>('_putws');
  late final __putws = __putwsPtr.asFunction<Dart_putws>(isLeaf: true);

  int ungetwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ungetwc(
      _Character,
      _Stream,
    );
  }

  late final _ungetwcPtr =
      _lookup<ffi.NativeFunction<NativeUngetwc>>('ungetwc');
  late final _ungetwc = _ungetwcPtr.asFunction<DartUngetwc>(isLeaf: true);

  ffi.Pointer<FILE> _wfdopen(
    int _FileHandle,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfdopen(
      _FileHandle,
      _Mode,
    );
  }

  late final __wfdopenPtr =
      _lookup<ffi.NativeFunction<Native_wfdopen>>('_wfdopen');
  late final __wfdopen = __wfdopenPtr.asFunction<Dart_wfdopen>(isLeaf: true);

  ffi.Pointer<FILE> _wfopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfopen(
      _FileName,
      _Mode,
    );
  }

  late final __wfopenPtr =
      _lookup<ffi.NativeFunction<Native_wfopen>>('_wfopen');
  late final __wfopen = __wfopenPtr.asFunction<Dart_wfopen>(isLeaf: true);

  int _wfopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfopen_s(
      _Stream,
      _FileName,
      _Mode,
    );
  }

  late final __wfopen_sPtr =
      _lookup<ffi.NativeFunction<Native_wfopen_s>>('_wfopen_s');
  late final __wfopen_s = __wfopen_sPtr.asFunction<Dart_wfopen_s>(isLeaf: true);

  ffi.Pointer<FILE> _wfreopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return __wfreopen(
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final __wfreopenPtr =
      _lookup<ffi.NativeFunction<Native_wfreopen>>('_wfreopen');
  late final __wfreopen = __wfreopenPtr.asFunction<Dart_wfreopen>(isLeaf: true);

  int _wfreopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return __wfreopen_s(
      _Stream,
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final __wfreopen_sPtr =
      _lookup<ffi.NativeFunction<Native_wfreopen_s>>('_wfreopen_s');
  late final __wfreopen_s =
      __wfreopen_sPtr.asFunction<Dart_wfreopen_s>(isLeaf: true);

  ffi.Pointer<FILE> _wfsopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    int _ShFlag,
  ) {
    return __wfsopen(
      _FileName,
      _Mode,
      _ShFlag,
    );
  }

  late final __wfsopenPtr =
      _lookup<ffi.NativeFunction<Native_wfsopen>>('_wfsopen');
  late final __wfsopen = __wfsopenPtr.asFunction<Dart_wfsopen>(isLeaf: true);

  void _wperror(
    ffi.Pointer<ffi.WChar> _ErrorMessage,
  ) {
    return __wperror(
      _ErrorMessage,
    );
  }

  late final __wperrorPtr =
      _lookup<ffi.NativeFunction<Native_wperror>>('_wperror');
  late final __wperror = __wperrorPtr.asFunction<Dart_wperror>(isLeaf: true);

  ffi.Pointer<FILE> _wpopen(
    ffi.Pointer<ffi.WChar> _Command,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wpopen(
      _Command,
      _Mode,
    );
  }

  late final __wpopenPtr =
      _lookup<ffi.NativeFunction<Native_wpopen>>('_wpopen');
  late final __wpopen = __wpopenPtr.asFunction<Dart_wpopen>(isLeaf: true);

  int _wremove(
    ffi.Pointer<ffi.WChar> _FileName,
  ) {
    return __wremove(
      _FileName,
    );
  }

  late final __wremovePtr =
      _lookup<ffi.NativeFunction<Native_wremove>>('_wremove');
  late final __wremove = __wremovePtr.asFunction<Dart_wremove>(isLeaf: true);

  ffi.Pointer<ffi.WChar> _wtempnam(
    ffi.Pointer<ffi.WChar> _Directory,
    ffi.Pointer<ffi.WChar> _FilePrefix,
  ) {
    return __wtempnam(
      _Directory,
      _FilePrefix,
    );
  }

  late final __wtempnamPtr =
      _lookup<ffi.NativeFunction<Native_wtempnam>>('_wtempnam');
  late final __wtempnam = __wtempnamPtr.asFunction<Dart_wtempnam>(isLeaf: true);

  int _wtmpnam_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
  ) {
    return __wtmpnam_s(
      _Buffer,
      _BufferCount,
    );
  }

  late final __wtmpnam_sPtr =
      _lookup<ffi.NativeFunction<Native_wtmpnam_s>>('_wtmpnam_s');
  late final __wtmpnam_s =
      __wtmpnam_sPtr.asFunction<Dart_wtmpnam_s>(isLeaf: true);

  ffi.Pointer<ffi.WChar> _wtmpnam(
    ffi.Pointer<ffi.WChar> _Buffer,
  ) {
    return __wtmpnam(
      _Buffer,
    );
  }

  late final __wtmpnamPtr =
      _lookup<ffi.NativeFunction<Native_wtmpnam>>('_wtmpnam');
  late final __wtmpnam = __wtmpnamPtr.asFunction<Dart_wtmpnam>(isLeaf: true);

  int _fgetwc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fgetwc_nolock(
      _Stream,
    );
  }

  late final __fgetwc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fgetwc_nolock>>('_fgetwc_nolock');
  late final __fgetwc_nolock =
      __fgetwc_nolockPtr.asFunction<Dart_fgetwc_nolock>(isLeaf: true);

  int _fputwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fputwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __fputwc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fputwc_nolock>>('_fputwc_nolock');
  late final __fputwc_nolock =
      __fputwc_nolockPtr.asFunction<Dart_fputwc_nolock>(isLeaf: true);

  int _getwc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getwc_nolock(
      _Stream,
    );
  }

  late final __getwc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_getwc_nolock>>('_getwc_nolock');
  late final __getwc_nolock =
      __getwc_nolockPtr.asFunction<Dart_getwc_nolock>(isLeaf: true);

  int _putwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __putwc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_putwc_nolock>>('_putwc_nolock');
  late final __putwc_nolock =
      __putwc_nolockPtr.asFunction<Dart_putwc_nolock>(isLeaf: true);

  int _ungetwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ungetwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __ungetwc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_ungetwc_nolock>>('_ungetwc_nolock');
  late final __ungetwc_nolock =
      __ungetwc_nolockPtr.asFunction<Dart_ungetwc_nolock>(isLeaf: true);

  int __stdio_common_vfwprintf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfwprintf>>(
          '__stdio_common_vfwprintf');
  late final ___stdio_common_vfwprintf = ___stdio_common_vfwprintfPtr
      .asFunction<Dart__stdio_common_vfwprintf>(isLeaf: true);

  int __stdio_common_vfwprintf_s(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf_s(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfwprintf_s>>(
          '__stdio_common_vfwprintf_s');
  late final ___stdio_common_vfwprintf_s = ___stdio_common_vfwprintf_sPtr
      .asFunction<Dart__stdio_common_vfwprintf_s>(isLeaf: true);

  int __stdio_common_vfwprintf_p(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf_p(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintf_pPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfwprintf_p>>(
          '__stdio_common_vfwprintf_p');
  late final ___stdio_common_vfwprintf_p = ___stdio_common_vfwprintf_pPtr
      .asFunction<Dart__stdio_common_vfwprintf_p>(isLeaf: true);

  int __stdio_common_vfwscanf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwscanf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwscanfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfwscanf>>(
          '__stdio_common_vfwscanf');
  late final ___stdio_common_vfwscanf = ___stdio_common_vfwscanfPtr
      .asFunction<Dart__stdio_common_vfwscanf>(isLeaf: true);

  int __stdio_common_vswprintf(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vswprintf>>(
          '__stdio_common_vswprintf');
  late final ___stdio_common_vswprintf = ___stdio_common_vswprintfPtr
      .asFunction<Dart__stdio_common_vswprintf>(isLeaf: true);

  int __stdio_common_vswprintf_s(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vswprintf_s>>(
          '__stdio_common_vswprintf_s');
  late final ___stdio_common_vswprintf_s = ___stdio_common_vswprintf_sPtr
      .asFunction<Dart__stdio_common_vswprintf_s>(isLeaf: true);

  int __stdio_common_vsnwprintf_s(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsnwprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _MaxCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsnwprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsnwprintf_s>>(
          '__stdio_common_vsnwprintf_s');
  late final ___stdio_common_vsnwprintf_s = ___stdio_common_vsnwprintf_sPtr
      .asFunction<Dart__stdio_common_vsnwprintf_s>(isLeaf: true);

  int __stdio_common_vswprintf_p(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf_p(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintf_pPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vswprintf_p>>(
          '__stdio_common_vswprintf_p');
  late final ___stdio_common_vswprintf_p = ___stdio_common_vswprintf_pPtr
      .asFunction<Dart__stdio_common_vswprintf_p>(isLeaf: true);

  int __stdio_common_vswscanf(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswscanf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswscanfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vswscanf>>(
          '__stdio_common_vswscanf');
  late final ___stdio_common_vswscanf = ___stdio_common_vswscanfPtr
      .asFunction<Dart__stdio_common_vswscanf>(isLeaf: true);

  int _get_stream_buffer_pointers(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Base,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Pointer,
    ffi.Pointer<ffi.Pointer<ffi.Int>> _Count,
  ) {
    return __get_stream_buffer_pointers(
      _Stream,
      _Base,
      _Pointer,
      _Count,
    );
  }

  late final __get_stream_buffer_pointersPtr =
      _lookup<ffi.NativeFunction<Native_get_stream_buffer_pointers>>(
          '_get_stream_buffer_pointers');
  late final __get_stream_buffer_pointers = __get_stream_buffer_pointersPtr
      .asFunction<Dart_get_stream_buffer_pointers>(isLeaf: true);

  int clearerr_s(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _clearerr_s(
      _Stream,
    );
  }

  late final _clearerr_sPtr =
      _lookup<ffi.NativeFunction<NativeClearerr_s>>('clearerr_s');
  late final _clearerr_s =
      _clearerr_sPtr.asFunction<DartClearerr_s>(isLeaf: true);

  int fopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return _fopen_s(
      _Stream,
      _FileName,
      _Mode,
    );
  }

  late final _fopen_sPtr =
      _lookup<ffi.NativeFunction<NativeFopen_s>>('fopen_s');
  late final _fopen_s = _fopen_sPtr.asFunction<DartFopen_s>(isLeaf: true);

  int fread_s(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fread_s(
      _Buffer,
      _BufferSize,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _fread_sPtr =
      _lookup<ffi.NativeFunction<NativeFread_s>>('fread_s');
  late final _fread_s = _fread_sPtr.asFunction<DartFread_s>(isLeaf: true);

  int freopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return _freopen_s(
      _Stream,
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final _freopen_sPtr =
      _lookup<ffi.NativeFunction<NativeFreopen_s>>('freopen_s');
  late final _freopen_s = _freopen_sPtr.asFunction<DartFreopen_s>(isLeaf: true);

  ffi.Pointer<ffi.Char> gets_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _Size,
  ) {
    return _gets_s(
      _Buffer,
      _Size,
    );
  }

  late final _gets_sPtr = _lookup<ffi.NativeFunction<NativeGets_s>>('gets_s');
  late final _gets_s = _gets_sPtr.asFunction<DartGets_s>(isLeaf: true);

  int tmpfile_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
  ) {
    return _tmpfile_s(
      _Stream,
    );
  }

  late final _tmpfile_sPtr =
      _lookup<ffi.NativeFunction<NativeTmpfile_s>>('tmpfile_s');
  late final _tmpfile_s = _tmpfile_sPtr.asFunction<DartTmpfile_s>(isLeaf: true);

  int tmpnam_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _Size,
  ) {
    return _tmpnam_s(
      _Buffer,
      _Size,
    );
  }

  late final _tmpnam_sPtr =
      _lookup<ffi.NativeFunction<NativeTmpnam_s>>('tmpnam_s');
  late final _tmpnam_s = _tmpnam_sPtr.asFunction<DartTmpnam_s>(isLeaf: true);

  void clearerr(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _clearerr(
      _Stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<NativeClearerr>>('clearerr');
  late final _clearerr = _clearerrPtr.asFunction<DartClearerr>(isLeaf: true);

  int fclose(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fclose(
      _Stream,
    );
  }

  late final _fclosePtr = _lookup<ffi.NativeFunction<NativeFclose>>('fclose');
  late final _fclose = _fclosePtr.asFunction<DartFclose>(isLeaf: true);

  int _fcloseall() {
    return __fcloseall();
  }

  late final __fcloseallPtr =
      _lookup<ffi.NativeFunction<Native_fcloseall>>('_fcloseall');
  late final __fcloseall =
      __fcloseallPtr.asFunction<Dart_fcloseall>(isLeaf: true);

  ffi.Pointer<FILE> _fdopen(
    int _FileHandle,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return __fdopen(
      _FileHandle,
      _Mode,
    );
  }

  late final __fdopenPtr =
      _lookup<ffi.NativeFunction<Native_fdopen>>('_fdopen');
  late final __fdopen = __fdopenPtr.asFunction<Dart_fdopen>(isLeaf: true);

  int feof(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _feof(
      _Stream,
    );
  }

  late final _feofPtr = _lookup<ffi.NativeFunction<NativeFeof>>('feof');
  late final _feof = _feofPtr.asFunction<DartFeof>(isLeaf: true);

  int ferror(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ferror(
      _Stream,
    );
  }

  late final _ferrorPtr = _lookup<ffi.NativeFunction<NativeFerror>>('ferror');
  late final _ferror = _ferrorPtr.asFunction<DartFerror>(isLeaf: true);

  int fflush(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fflush(
      _Stream,
    );
  }

  late final _fflushPtr = _lookup<ffi.NativeFunction<NativeFflush>>('fflush');
  late final _fflush = _fflushPtr.asFunction<DartFflush>(isLeaf: true);

  int fgetc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetc(
      _Stream,
    );
  }

  late final _fgetcPtr = _lookup<ffi.NativeFunction<NativeFgetc>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<DartFgetc>(isLeaf: true);

  int _fgetchar() {
    return __fgetchar();
  }

  late final __fgetcharPtr =
      _lookup<ffi.NativeFunction<Native_fgetchar>>('_fgetchar');
  late final __fgetchar = __fgetcharPtr.asFunction<Dart_fgetchar>(isLeaf: true);

  int fgetpos(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<fpos_t> _Position,
  ) {
    return _fgetpos(
      _Stream,
      _Position,
    );
  }

  late final _fgetposPtr =
      _lookup<ffi.NativeFunction<NativeFgetpos>>('fgetpos');
  late final _fgetpos = _fgetposPtr.asFunction<DartFgetpos>(isLeaf: true);

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> _Buffer,
    int _MaxCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgets(
      _Buffer,
      _MaxCount,
      _Stream,
    );
  }

  late final _fgetsPtr = _lookup<ffi.NativeFunction<NativeFgets>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<DartFgets>(isLeaf: true);

  int _fileno(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fileno(
      _Stream,
    );
  }

  late final __filenoPtr =
      _lookup<ffi.NativeFunction<Native_fileno>>('_fileno');
  late final __fileno = __filenoPtr.asFunction<Dart_fileno>(isLeaf: true);

  int _flushall() {
    return __flushall();
  }

  late final __flushallPtr =
      _lookup<ffi.NativeFunction<Native_flushall>>('_flushall');
  late final __flushall = __flushallPtr.asFunction<Dart_flushall>(isLeaf: true);

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return _fopen(
      _FileName,
      _Mode,
    );
  }

  late final _fopenPtr = _lookup<ffi.NativeFunction<NativeFopen>>('fopen');
  late final _fopen = _fopenPtr.asFunction<DartFopen>(isLeaf: true);

  int fputc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputc(
      _Character,
      _Stream,
    );
  }

  late final _fputcPtr = _lookup<ffi.NativeFunction<NativeFputc>>('fputc');
  late final _fputc = _fputcPtr.asFunction<DartFputc>(isLeaf: true);

  int _fputchar(
    int _Character,
  ) {
    return __fputchar(
      _Character,
    );
  }

  late final __fputcharPtr =
      _lookup<ffi.NativeFunction<Native_fputchar>>('_fputchar');
  late final __fputchar = __fputcharPtr.asFunction<Dart_fputchar>(isLeaf: true);

  int fputs(
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputs(
      _Buffer,
      _Stream,
    );
  }

  late final _fputsPtr = _lookup<ffi.NativeFunction<NativeFputs>>('fputs');
  late final _fputs = _fputsPtr.asFunction<DartFputs>(isLeaf: true);

  int fread(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fread(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _freadPtr = _lookup<ffi.NativeFunction<NativeFread>>('fread');
  late final _fread = _freadPtr.asFunction<DartFread>(isLeaf: true);

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _freopen(
      _FileName,
      _Mode,
      _Stream,
    );
  }

  late final _freopenPtr =
      _lookup<ffi.NativeFunction<NativeFreopen>>('freopen');
  late final _freopen = _freopenPtr.asFunction<DartFreopen>(isLeaf: true);

  ffi.Pointer<FILE> _fsopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    int _ShFlag,
  ) {
    return __fsopen(
      _FileName,
      _Mode,
      _ShFlag,
    );
  }

  late final __fsopenPtr =
      _lookup<ffi.NativeFunction<Native_fsopen>>('_fsopen');
  late final __fsopen = __fsopenPtr.asFunction<Dart_fsopen>(isLeaf: true);

  int fsetpos(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<fpos_t> _Position,
  ) {
    return _fsetpos(
      _Stream,
      _Position,
    );
  }

  late final _fsetposPtr =
      _lookup<ffi.NativeFunction<NativeFsetpos>>('fsetpos');
  late final _fsetpos = _fsetposPtr.asFunction<DartFsetpos>(isLeaf: true);

  int fseek(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return _fseek(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final _fseekPtr = _lookup<ffi.NativeFunction<NativeFseek>>('fseek');
  late final _fseek = _fseekPtr.asFunction<DartFseek>(isLeaf: true);

  int _fseeki64(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseeki64(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseeki64Ptr =
      _lookup<ffi.NativeFunction<Native_fseeki64>>('_fseeki64');
  late final __fseeki64 = __fseeki64Ptr.asFunction<Dart_fseeki64>(isLeaf: true);

  int ftell(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ftell(
      _Stream,
    );
  }

  late final _ftellPtr = _lookup<ffi.NativeFunction<NativeFtell>>('ftell');
  late final _ftell = _ftellPtr.asFunction<DartFtell>(isLeaf: true);

  int _ftelli64(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftelli64(
      _Stream,
    );
  }

  late final __ftelli64Ptr =
      _lookup<ffi.NativeFunction<Native_ftelli64>>('_ftelli64');
  late final __ftelli64 = __ftelli64Ptr.asFunction<Dart_ftelli64>(isLeaf: true);

  int fwrite(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fwrite(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _fwritePtr = _lookup<ffi.NativeFunction<NativeFwrite>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<DartFwrite>(isLeaf: true);

  int getc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getc(
      _Stream,
    );
  }

  late final _getcPtr = _lookup<ffi.NativeFunction<NativeGetc>>('getc');
  late final _getc = _getcPtr.asFunction<DartGetc>(isLeaf: true);

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<NativeGetchar>>('getchar');
  late final _getchar = _getcharPtr.asFunction<DartGetchar>(isLeaf: true);

  int _getmaxstdio() {
    return __getmaxstdio();
  }

  late final __getmaxstdioPtr =
      _lookup<ffi.NativeFunction<Native_getmaxstdio>>('_getmaxstdio');
  late final __getmaxstdio =
      __getmaxstdioPtr.asFunction<Dart_getmaxstdio>(isLeaf: true);

  int _getw(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getw(
      _Stream,
    );
  }

  late final __getwPtr = _lookup<ffi.NativeFunction<Native_getw>>('_getw');
  late final __getw = __getwPtr.asFunction<Dart_getw>(isLeaf: true);

  void perror(
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return _perror(
      _ErrorMessage,
    );
  }

  late final _perrorPtr = _lookup<ffi.NativeFunction<NativePerror>>('perror');
  late final _perror = _perrorPtr.asFunction<DartPerror>(isLeaf: true);

  int _pclose(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __pclose(
      _Stream,
    );
  }

  late final __pclosePtr =
      _lookup<ffi.NativeFunction<Native_pclose>>('_pclose');
  late final __pclose = __pclosePtr.asFunction<Dart_pclose>(isLeaf: true);

  ffi.Pointer<FILE> _popen(
    ffi.Pointer<ffi.Char> _Command,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return __popen(
      _Command,
      _Mode,
    );
  }

  late final __popenPtr = _lookup<ffi.NativeFunction<Native_popen>>('_popen');
  late final __popen = __popenPtr.asFunction<Dart_popen>(isLeaf: true);

  int putc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putc(
      _Character,
      _Stream,
    );
  }

  late final _putcPtr = _lookup<ffi.NativeFunction<NativePutc>>('putc');
  late final _putc = _putcPtr.asFunction<DartPutc>(isLeaf: true);

  int putchar(
    int _Character,
  ) {
    return _putchar(
      _Character,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<NativePutchar>>('putchar');
  late final _putchar = _putcharPtr.asFunction<DartPutchar>(isLeaf: true);

  int puts(
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _puts(
      _Buffer,
    );
  }

  late final _putsPtr = _lookup<ffi.NativeFunction<NativePuts>>('puts');
  late final _puts = _putsPtr.asFunction<DartPuts>(isLeaf: true);

  int _putw(
    int _Word,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putw(
      _Word,
      _Stream,
    );
  }

  late final __putwPtr = _lookup<ffi.NativeFunction<Native_putw>>('_putw');
  late final __putw = __putwPtr.asFunction<Dart_putw>(isLeaf: true);

  int remove(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return _remove(
      _FileName,
    );
  }

  late final _removePtr = _lookup<ffi.NativeFunction<NativeRemove>>('remove');
  late final _remove = _removePtr.asFunction<DartRemove>(isLeaf: true);

  int rename(
    ffi.Pointer<ffi.Char> _OldFileName,
    ffi.Pointer<ffi.Char> _NewFileName,
  ) {
    return _rename(
      _OldFileName,
      _NewFileName,
    );
  }

  late final _renamePtr = _lookup<ffi.NativeFunction<NativeRename>>('rename');
  late final _rename = _renamePtr.asFunction<DartRename>(isLeaf: true);

  int _unlink(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return __unlink(
      _FileName,
    );
  }

  late final __unlinkPtr =
      _lookup<ffi.NativeFunction<Native_unlink>>('_unlink');
  late final __unlink = __unlinkPtr.asFunction<Dart_unlink>(isLeaf: true);

  int unlink(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return _unlink1(
      _FileName,
    );
  }

  late final _unlinkPtr = _lookup<ffi.NativeFunction<NativeUnlink>>('unlink');
  late final _unlink1 = _unlinkPtr.asFunction<DartUnlink>(isLeaf: true);

  void rewind(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _rewind(
      _Stream,
    );
  }

  late final _rewindPtr = _lookup<ffi.NativeFunction<NativeRewind>>('rewind');
  late final _rewind = _rewindPtr.asFunction<DartRewind>(isLeaf: true);

  int _rmtmp() {
    return __rmtmp();
  }

  late final __rmtmpPtr = _lookup<ffi.NativeFunction<Native_rmtmp>>('_rmtmp');
  late final __rmtmp = __rmtmpPtr.asFunction<Dart_rmtmp>(isLeaf: true);

  void setbuf(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _setbuf(
      _Stream,
      _Buffer,
    );
  }

  late final _setbufPtr = _lookup<ffi.NativeFunction<NativeSetbuf>>('setbuf');
  late final _setbuf = _setbufPtr.asFunction<DartSetbuf>(isLeaf: true);

  int _setmaxstdio(
    int _Maximum,
  ) {
    return __setmaxstdio(
      _Maximum,
    );
  }

  late final __setmaxstdioPtr =
      _lookup<ffi.NativeFunction<Native_setmaxstdio>>('_setmaxstdio');
  late final __setmaxstdio =
      __setmaxstdioPtr.asFunction<Dart_setmaxstdio>(isLeaf: true);

  int setvbuf(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer,
    int _Mode,
    int _Size,
  ) {
    return _setvbuf(
      _Stream,
      _Buffer,
      _Mode,
      _Size,
    );
  }

  late final _setvbufPtr =
      _lookup<ffi.NativeFunction<NativeSetvbuf>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<DartSetvbuf>(isLeaf: true);

  ffi.Pointer<ffi.Char> _tempnam(
    ffi.Pointer<ffi.Char> _DirectoryName,
    ffi.Pointer<ffi.Char> _FilePrefix,
  ) {
    return __tempnam(
      _DirectoryName,
      _FilePrefix,
    );
  }

  late final __tempnamPtr =
      _lookup<ffi.NativeFunction<Native_tempnam>>('_tempnam');
  late final __tempnam = __tempnamPtr.asFunction<Dart_tempnam>(isLeaf: true);

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<NativeTmpfile>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<DartTmpfile>(isLeaf: true);

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _tmpnam(
      _Buffer,
    );
  }

  late final _tmpnamPtr = _lookup<ffi.NativeFunction<NativeTmpnam>>('tmpnam');
  late final _tmpnam = _tmpnamPtr.asFunction<DartTmpnam>(isLeaf: true);

  int ungetc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ungetc(
      _Character,
      _Stream,
    );
  }

  late final _ungetcPtr = _lookup<ffi.NativeFunction<NativeUngetc>>('ungetc');
  late final _ungetc = _ungetcPtr.asFunction<DartUngetc>(isLeaf: true);

  void _lock_file(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __lock_file(
      _Stream,
    );
  }

  late final __lock_filePtr =
      _lookup<ffi.NativeFunction<Native_lock_file>>('_lock_file');
  late final __lock_file =
      __lock_filePtr.asFunction<Dart_lock_file>(isLeaf: true);

  void _unlock_file(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __unlock_file(
      _Stream,
    );
  }

  late final __unlock_filePtr =
      _lookup<ffi.NativeFunction<Native_unlock_file>>('_unlock_file');
  late final __unlock_file =
      __unlock_filePtr.asFunction<Dart_unlock_file>(isLeaf: true);

  int _fclose_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fclose_nolock(
      _Stream,
    );
  }

  late final __fclose_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fclose_nolock>>('_fclose_nolock');
  late final __fclose_nolock =
      __fclose_nolockPtr.asFunction<Dart_fclose_nolock>(isLeaf: true);

  int _fflush_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fflush_nolock(
      _Stream,
    );
  }

  late final __fflush_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fflush_nolock>>('_fflush_nolock');
  late final __fflush_nolock =
      __fflush_nolockPtr.asFunction<Dart_fflush_nolock>(isLeaf: true);

  int _fgetc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fgetc_nolock(
      _Stream,
    );
  }

  late final __fgetc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fgetc_nolock>>('_fgetc_nolock');
  late final __fgetc_nolock =
      __fgetc_nolockPtr.asFunction<Dart_fgetc_nolock>(isLeaf: true);

  int _fputc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fputc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __fputc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fputc_nolock>>('_fputc_nolock');
  late final __fputc_nolock =
      __fputc_nolockPtr.asFunction<Dart_fputc_nolock>(isLeaf: true);

  int _fread_nolock(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fread_nolock(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fread_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fread_nolock>>('_fread_nolock');
  late final __fread_nolock =
      __fread_nolockPtr.asFunction<Dart_fread_nolock>(isLeaf: true);

  int _fread_nolock_s(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fread_nolock_s(
      _Buffer,
      _BufferSize,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fread_nolock_sPtr =
      _lookup<ffi.NativeFunction<Native_fread_nolock_s>>('_fread_nolock_s');
  late final __fread_nolock_s =
      __fread_nolock_sPtr.asFunction<Dart_fread_nolock_s>(isLeaf: true);

  int _fseek_nolock(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseek_nolock(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseek_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fseek_nolock>>('_fseek_nolock');
  late final __fseek_nolock =
      __fseek_nolockPtr.asFunction<Dart_fseek_nolock>(isLeaf: true);

  int _fseeki64_nolock(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseeki64_nolock(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseeki64_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fseeki64_nolock>>('_fseeki64_nolock');
  late final __fseeki64_nolock =
      __fseeki64_nolockPtr.asFunction<Dart_fseeki64_nolock>(isLeaf: true);

  int _ftell_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftell_nolock(
      _Stream,
    );
  }

  late final __ftell_nolockPtr =
      _lookup<ffi.NativeFunction<Native_ftell_nolock>>('_ftell_nolock');
  late final __ftell_nolock =
      __ftell_nolockPtr.asFunction<Dart_ftell_nolock>(isLeaf: true);

  int _ftelli64_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftelli64_nolock(
      _Stream,
    );
  }

  late final __ftelli64_nolockPtr =
      _lookup<ffi.NativeFunction<Native_ftelli64_nolock>>('_ftelli64_nolock');
  late final __ftelli64_nolock =
      __ftelli64_nolockPtr.asFunction<Dart_ftelli64_nolock>(isLeaf: true);

  int _fwrite_nolock(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fwrite_nolock(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fwrite_nolockPtr =
      _lookup<ffi.NativeFunction<Native_fwrite_nolock>>('_fwrite_nolock');
  late final __fwrite_nolock =
      __fwrite_nolockPtr.asFunction<Dart_fwrite_nolock>(isLeaf: true);

  int _getc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getc_nolock(
      _Stream,
    );
  }

  late final __getc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_getc_nolock>>('_getc_nolock');
  late final __getc_nolock =
      __getc_nolockPtr.asFunction<Dart_getc_nolock>(isLeaf: true);

  int _putc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __putc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_putc_nolock>>('_putc_nolock');
  late final __putc_nolock =
      __putc_nolockPtr.asFunction<Dart_putc_nolock>(isLeaf: true);

  int _ungetc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ungetc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __ungetc_nolockPtr =
      _lookup<ffi.NativeFunction<Native_ungetc_nolock>>('_ungetc_nolock');
  late final __ungetc_nolock =
      __ungetc_nolockPtr.asFunction<Dart_ungetc_nolock>(isLeaf: true);

  ffi.Pointer<ffi.Int> __p__commode() {
    return ___p__commode();
  }

  late final ___p__commodePtr =
      _lookup<ffi.NativeFunction<Native__p__commode>>('__p__commode');
  late final ___p__commode =
      ___p__commodePtr.asFunction<Dart__p__commode>(isLeaf: true);

  int __stdio_common_vfprintf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfprintf>>(
          '__stdio_common_vfprintf');
  late final ___stdio_common_vfprintf = ___stdio_common_vfprintfPtr
      .asFunction<Dart__stdio_common_vfprintf>(isLeaf: true);

  int __stdio_common_vfprintf_s(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf_s(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfprintf_s>>(
          '__stdio_common_vfprintf_s');
  late final ___stdio_common_vfprintf_s = ___stdio_common_vfprintf_sPtr
      .asFunction<Dart__stdio_common_vfprintf_s>(isLeaf: true);

  int __stdio_common_vfprintf_p(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf_p(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintf_pPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfprintf_p>>(
          '__stdio_common_vfprintf_p');
  late final ___stdio_common_vfprintf_p = ___stdio_common_vfprintf_pPtr
      .asFunction<Dart__stdio_common_vfprintf_p>(isLeaf: true);

  int _set_printf_count_output(
    int _Value,
  ) {
    return __set_printf_count_output(
      _Value,
    );
  }

  late final __set_printf_count_outputPtr =
      _lookup<ffi.NativeFunction<Native_set_printf_count_output>>(
          '_set_printf_count_output');
  late final __set_printf_count_output = __set_printf_count_outputPtr
      .asFunction<Dart_set_printf_count_output>(isLeaf: true);

  int _get_printf_count_output() {
    return __get_printf_count_output();
  }

  late final __get_printf_count_outputPtr =
      _lookup<ffi.NativeFunction<Native_get_printf_count_output>>(
          '_get_printf_count_output');
  late final __get_printf_count_output = __get_printf_count_outputPtr
      .asFunction<Dart_get_printf_count_output>(isLeaf: true);

  int __stdio_common_vfscanf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _Arglist,
  ) {
    return ___stdio_common_vfscanf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _Arglist,
    );
  }

  late final ___stdio_common_vfscanfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vfscanf>>(
          '__stdio_common_vfscanf');
  late final ___stdio_common_vfscanf = ___stdio_common_vfscanfPtr
      .asFunction<Dart__stdio_common_vfscanf>(isLeaf: true);

  int __stdio_common_vsprintf(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsprintf>>(
          '__stdio_common_vsprintf');
  late final ___stdio_common_vsprintf = ___stdio_common_vsprintfPtr
      .asFunction<Dart__stdio_common_vsprintf>(isLeaf: true);

  int __stdio_common_vsprintf_s(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsprintf_s>>(
          '__stdio_common_vsprintf_s');
  late final ___stdio_common_vsprintf_s = ___stdio_common_vsprintf_sPtr
      .asFunction<Dart__stdio_common_vsprintf_s>(isLeaf: true);

  int __stdio_common_vsnprintf_s(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsnprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _MaxCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsnprintf_sPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsnprintf_s>>(
          '__stdio_common_vsnprintf_s');
  late final ___stdio_common_vsnprintf_s = ___stdio_common_vsnprintf_sPtr
      .asFunction<Dart__stdio_common_vsnprintf_s>(isLeaf: true);

  int __stdio_common_vsprintf_p(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf_p(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintf_pPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsprintf_p>>(
          '__stdio_common_vsprintf_p');
  late final ___stdio_common_vsprintf_p = ___stdio_common_vsprintf_pPtr
      .asFunction<Dart__stdio_common_vsprintf_p>(isLeaf: true);

  int __stdio_common_vsscanf(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsscanf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsscanfPtr =
      _lookup<ffi.NativeFunction<Native__stdio_common_vsscanf>>(
          '__stdio_common_vsscanf');
  late final ___stdio_common_vsscanf = ___stdio_common_vsscanfPtr
      .asFunction<Dart__stdio_common_vsscanf>(isLeaf: true);

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> _Directory,
    ffi.Pointer<ffi.Char> _FilePrefix,
  ) {
    return _tempnam1(
      _Directory,
      _FilePrefix,
    );
  }

  late final _tempnamPtr =
      _lookup<ffi.NativeFunction<NativeTempnam>>('tempnam');
  late final _tempnam1 = _tempnamPtr.asFunction<DartTempnam>(isLeaf: true);

  int fcloseall() {
    return _fcloseall1();
  }

  late final _fcloseallPtr =
      _lookup<ffi.NativeFunction<NativeFcloseall>>('fcloseall');
  late final _fcloseall1 =
      _fcloseallPtr.asFunction<DartFcloseall>(isLeaf: true);

  ffi.Pointer<FILE> fdopen(
    int _FileHandle,
    ffi.Pointer<ffi.Char> _Format,
  ) {
    return _fdopen1(
      _FileHandle,
      _Format,
    );
  }

  late final _fdopenPtr = _lookup<ffi.NativeFunction<NativeFdopen>>('fdopen');
  late final _fdopen1 = _fdopenPtr.asFunction<DartFdopen>(isLeaf: true);

  int fgetchar() {
    return _fgetchar1();
  }

  late final _fgetcharPtr =
      _lookup<ffi.NativeFunction<NativeFgetchar>>('fgetchar');
  late final _fgetchar1 = _fgetcharPtr.asFunction<DartFgetchar>(isLeaf: true);

  int fileno(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fileno1(
      _Stream,
    );
  }

  late final _filenoPtr = _lookup<ffi.NativeFunction<NativeFileno>>('fileno');
  late final _fileno1 = _filenoPtr.asFunction<DartFileno>(isLeaf: true);

  int flushall() {
    return _flushall1();
  }

  late final _flushallPtr =
      _lookup<ffi.NativeFunction<NativeFlushall>>('flushall');
  late final _flushall1 = _flushallPtr.asFunction<DartFlushall>(isLeaf: true);

  int fputchar(
    int _Ch,
  ) {
    return _fputchar1(
      _Ch,
    );
  }

  late final _fputcharPtr =
      _lookup<ffi.NativeFunction<NativeFputchar>>('fputchar');
  late final _fputchar1 = _fputcharPtr.asFunction<DartFputchar>(isLeaf: true);

  int getw(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getw1(
      _Stream,
    );
  }

  late final _getwPtr = _lookup<ffi.NativeFunction<NativeGetw>>('getw');
  late final _getw1 = _getwPtr.asFunction<DartGetw>(isLeaf: true);

  int putw(
    int _Ch,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putw1(
      _Ch,
      _Stream,
    );
  }

  late final _putwPtr = _lookup<ffi.NativeFunction<NativePutw>>('putw');
  late final _putw1 = _putwPtr.asFunction<DartPutw>(isLeaf: true);

  int rmtmp() {
    return _rmtmp1();
  }

  late final _rmtmpPtr = _lookup<ffi.NativeFunction<NativeRmtmp>>('rmtmp');
  late final _rmtmp1 = _rmtmpPtr.asFunction<DartRmtmp>(isLeaf: true);

  /// Parses the contents of the ID header packet of an Ogg Opus stream.
  /// \param[out] _head Returns the contents of the parsed packet.
  /// The contents of this structure are untouched on error.
  /// This may be <code>NULL</code> to merely test the header
  /// for validity.
  /// \param[in]  _data The contents of the ID header packet.
  /// \param      _len  The number of bytes of data in the ID header packet.
  /// \return 0 on success or a negative value on error.
  /// \retval #OP_ENOTFORMAT If the data does not start with the "OpusHead"
  /// string.
  /// \retval #OP_EVERSION   If the version field signaled a version this library
  /// does not know how to parse.
  /// \retval #OP_EIMPL      If the channel mapping family was 255, which general
  /// purpose players should not attempt to play.
  /// \retval #OP_EBADHEADER If the contents of the packet otherwise violate the
  /// Ogg Opus specification:
  /// <ul>
  /// <li>Insufficient data,</li>
  /// <li>Too much data for the known minor versions,</li>
  /// <li>An unrecognized channel mapping family,</li>
  /// <li>Zero channels or too many channels,</li>
  /// <li>Zero coded streams,</li>
  /// <li>Too many coupled streams, or</li>
  /// <li>An invalid channel mapping index.</li>
  /// </ul>
  int opus_head_parse(
    ffi.Pointer<OpusHead> _head,
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _len,
  ) {
    return _opus_head_parse(
      _head,
      _data,
      _len,
    );
  }

  late final _opus_head_parsePtr =
      _lookup<ffi.NativeFunction<NativeOpus_head_parse>>('opus_head_parse');
  late final _opus_head_parse =
      _opus_head_parsePtr.asFunction<DartOpus_head_parse>(isLeaf: true);

  /// Converts a granule position to a sample offset for a given Ogg Opus stream.
  /// The sample offset is simply <code>_gp-_head->pre_skip</code>.
  /// Granule position values smaller than OpusHead#pre_skip correspond to audio
  /// that should never be played, and thus have no associated sample offset.
  /// This function returns -1 for such values.
  /// This function also correctly handles extremely large granule positions,
  /// which may have wrapped around to a negative number when stored in a signed
  /// ogg_int64_t value.
  /// \param _head The #OpusHead information from the ID header of the stream.
  /// \param _gp   The granule position to convert.
  /// \return The sample offset associated with the given granule position
  /// (counting at a 48 kHz sampling rate), or the special value -1 on
  /// error (i.e., the granule position was smaller than the pre-skip
  /// amount).
  int opus_granule_sample(
    ffi.Pointer<OpusHead> _head,
    int _gp,
  ) {
    return _opus_granule_sample(
      _head,
      _gp,
    );
  }

  late final _opus_granule_samplePtr =
      _lookup<ffi.NativeFunction<NativeOpus_granule_sample>>(
          'opus_granule_sample');
  late final _opus_granule_sample =
      _opus_granule_samplePtr.asFunction<DartOpus_granule_sample>(isLeaf: true);

  /// Parses the contents of the 'comment' header packet of an Ogg Opus stream.
  /// \param[out] _tags An uninitialized #OpusTags structure.
  /// This returns the contents of the parsed packet.
  /// The contents of this structure are untouched on error.
  /// This may be <code>NULL</code> to merely test the header
  /// for validity.
  /// \param[in]  _data The contents of the 'comment' header packet.
  /// \param      _len  The number of bytes of data in the 'info' header packet.
  /// \retval 0              Success.
  /// \retval #OP_ENOTFORMAT If the data does not start with the "OpusTags"
  /// string.
  /// \retval #OP_EBADHEADER If the contents of the packet otherwise violate the
  /// Ogg Opus specification.
  /// \retval #OP_EFAULT     If there wasn't enough memory to store the tags.
  int opus_tags_parse(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _len,
  ) {
    return _opus_tags_parse(
      _tags,
      _data,
      _len,
    );
  }

  late final _opus_tags_parsePtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_parse>>('opus_tags_parse');
  late final _opus_tags_parse =
      _opus_tags_parsePtr.asFunction<DartOpus_tags_parse>(isLeaf: true);

  /// Performs a deep copy of an #OpusTags structure.
  /// \param _dst The #OpusTags structure to copy into.
  /// If this function fails, the contents of this structure remain
  /// untouched.
  /// \param _src The #OpusTags structure to copy from.
  /// \retval 0          Success.
  /// \retval #OP_EFAULT If there wasn't enough memory to copy the tags.
  int opus_tags_copy(
    ffi.Pointer<OpusTags> _dst,
    ffi.Pointer<OpusTags> _src,
  ) {
    return _opus_tags_copy(
      _dst,
      _src,
    );
  }

  late final _opus_tags_copyPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_copy>>('opus_tags_copy');
  late final _opus_tags_copy =
      _opus_tags_copyPtr.asFunction<DartOpus_tags_copy>(isLeaf: true);

  /// Initializes an #OpusTags structure.
  /// This should be called on a freshly allocated #OpusTags structure before
  /// attempting to use it.
  /// \param _tags The #OpusTags structure to initialize.
  void opus_tags_init(
    ffi.Pointer<OpusTags> _tags,
  ) {
    return _opus_tags_init(
      _tags,
    );
  }

  late final _opus_tags_initPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_init>>('opus_tags_init');
  late final _opus_tags_init =
      _opus_tags_initPtr.asFunction<DartOpus_tags_init>(isLeaf: true);

  /// Add a (tag, value) pair to an initialized #OpusTags structure.
  /// \note Neither opus_tags_add() nor opus_tags_add_comment() support values
  /// containing embedded NULs, although the bitstream format does support them.
  /// To add such tags, you will need to manipulate the #OpusTags structure
  /// directly.
  /// \param _tags  The #OpusTags structure to add the (tag, value) pair to.
  /// \param _tag   A NUL-terminated, case-insensitive, ASCII string containing
  /// the tag to add (without an '=' character).
  /// \param _value A NUL-terminated UTF-8 containing the corresponding value.
  /// \return 0 on success, or a negative value on failure.
  /// \retval #OP_EFAULT An internal memory allocation failed.
  int opus_tags_add(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _tag,
    ffi.Pointer<ffi.Char> _value,
  ) {
    return _opus_tags_add(
      _tags,
      _tag,
      _value,
    );
  }

  late final _opus_tags_addPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_add>>('opus_tags_add');
  late final _opus_tags_add =
      _opus_tags_addPtr.asFunction<DartOpus_tags_add>(isLeaf: true);

  /// Add a comment to an initialized #OpusTags structure.
  /// \note Neither opus_tags_add_comment() nor opus_tags_add() support comments
  /// containing embedded NULs, although the bitstream format does support them.
  /// To add such tags, you will need to manipulate the #OpusTags structure
  /// directly.
  /// \param _tags    The #OpusTags structure to add the comment to.
  /// \param _comment A NUL-terminated UTF-8 string containing the comment in
  /// "TAG=value" form.
  /// \return 0 on success, or a negative value on failure.
  /// \retval #OP_EFAULT An internal memory allocation failed.
  int opus_tags_add_comment(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _comment,
  ) {
    return _opus_tags_add_comment(
      _tags,
      _comment,
    );
  }

  late final _opus_tags_add_commentPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_add_comment>>(
          'opus_tags_add_comment');
  late final _opus_tags_add_comment = _opus_tags_add_commentPtr
      .asFunction<DartOpus_tags_add_comment>(isLeaf: true);

  /// Replace the binary suffix data at the end of the packet (if any).
  /// \param _tags An initialized #OpusTags structure.
  /// \param _data A buffer of binary data to append after the encoded user
  /// comments.
  /// The least significant bit of the first byte of this data must
  /// be set (to ensure the data is preserved by other editors).
  /// \param _len  The number of bytes of binary data to append.
  /// This may be zero to remove any existing binary suffix data.
  /// \return 0 on success, or a negative value on error.
  /// \retval #OP_EINVAL \a _len was negative, or \a _len was positive but
  /// \a _data was <code>NULL</code> or the least significant
  /// bit of the first byte was not set.
  /// \retval #OP_EFAULT An internal memory allocation failed.
  int opus_tags_set_binary_suffix(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _len,
  ) {
    return _opus_tags_set_binary_suffix(
      _tags,
      _data,
      _len,
    );
  }

  late final _opus_tags_set_binary_suffixPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_set_binary_suffix>>(
          'opus_tags_set_binary_suffix');
  late final _opus_tags_set_binary_suffix = _opus_tags_set_binary_suffixPtr
      .asFunction<DartOpus_tags_set_binary_suffix>(isLeaf: true);

  /// Look up a comment value by its tag.
  /// \param _tags  An initialized #OpusTags structure.
  /// \param _tag   The tag to look up.
  /// \param _count The instance of the tag.
  /// The same tag can appear multiple times, each with a distinct
  /// value, so an index is required to retrieve them all.
  /// The order in which these values appear is significant and
  /// should be preserved.
  /// Use opus_tags_query_count() to get the legal range for the
  /// \a _count parameter.
  /// \return A pointer to the queried tag's value.
  /// This points directly to data in the #OpusTags structure.
  /// It should not be modified or freed by the application, and
  /// modifications to the structure may invalidate the pointer.
  /// \retval NULL If no matching tag is found.
  ffi.Pointer<ffi.Char> opus_tags_query(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _tag,
    int _count,
  ) {
    return _opus_tags_query(
      _tags,
      _tag,
      _count,
    );
  }

  late final _opus_tags_queryPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_query>>('opus_tags_query');
  late final _opus_tags_query =
      _opus_tags_queryPtr.asFunction<DartOpus_tags_query>(isLeaf: true);

  /// Look up the number of instances of a tag.
  /// Call this first when querying for a specific tag and then iterate over the
  /// number of instances with separate calls to opus_tags_query() to retrieve
  /// all the values for that tag in order.
  /// \param _tags An initialized #OpusTags structure.
  /// \param _tag  The tag to look up.
  /// \return The number of instances of this particular tag.
  int opus_tags_query_count(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _tag,
  ) {
    return _opus_tags_query_count(
      _tags,
      _tag,
    );
  }

  late final _opus_tags_query_countPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_query_count>>(
          'opus_tags_query_count');
  late final _opus_tags_query_count = _opus_tags_query_countPtr
      .asFunction<DartOpus_tags_query_count>(isLeaf: true);

  /// Retrieve the binary suffix data at the end of the packet (if any).
  /// \param      _tags An initialized #OpusTags structure.
  /// \param[out] _len  Returns the number of bytes of binary suffix data returned.
  /// \return A pointer to the binary suffix data, or <code>NULL</code> if none
  /// was present.
  ffi.Pointer<ffi.UnsignedChar> opus_tags_get_binary_suffix(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Int> _len,
  ) {
    return _opus_tags_get_binary_suffix(
      _tags,
      _len,
    );
  }

  late final _opus_tags_get_binary_suffixPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_get_binary_suffix>>(
          'opus_tags_get_binary_suffix');
  late final _opus_tags_get_binary_suffix = _opus_tags_get_binary_suffixPtr
      .asFunction<DartOpus_tags_get_binary_suffix>(isLeaf: true);

  /// Get the album gain from an R128_ALBUM_GAIN tag, if one was specified.
  /// This searches for the first R128_ALBUM_GAIN tag with a valid signed,
  /// 16-bit decimal integer value and returns the value.
  /// This routine is exposed merely for convenience for applications which wish
  /// to do something special with the album gain (i.e., display it).
  /// If you simply wish to apply the album gain instead of the header gain, you
  /// can use op_set_gain_offset() with an #OP_ALBUM_GAIN type and no offset.
  /// \param      _tags    An initialized #OpusTags structure.
  /// \param[out] _gain_q8 The album gain, in 1/256ths of a dB.
  /// This will lie in the range [-32768,32767], and should
  /// be applied in <em>addition</em> to the header gain.
  /// On error, no value is returned, and the previous
  /// contents remain unchanged.
  /// \return 0 on success, or a negative value on error.
  /// \retval #OP_FALSE There was no album gain available in the given tags.
  int opus_tags_get_album_gain(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Int> _gain_q8,
  ) {
    return _opus_tags_get_album_gain(
      _tags,
      _gain_q8,
    );
  }

  late final _opus_tags_get_album_gainPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_get_album_gain>>(
          'opus_tags_get_album_gain');
  late final _opus_tags_get_album_gain = _opus_tags_get_album_gainPtr
      .asFunction<DartOpus_tags_get_album_gain>(isLeaf: true);

  /// Get the track gain from an R128_TRACK_GAIN tag, if one was specified.
  /// This searches for the first R128_TRACK_GAIN tag with a valid signed,
  /// 16-bit decimal integer value and returns the value.
  /// This routine is exposed merely for convenience for applications which wish
  /// to do something special with the track gain (i.e., display it).
  /// If you simply wish to apply the track gain instead of the header gain, you
  /// can use op_set_gain_offset() with an #OP_TRACK_GAIN type and no offset.
  /// \param      _tags    An initialized #OpusTags structure.
  /// \param[out] _gain_q8 The track gain, in 1/256ths of a dB.
  /// This will lie in the range [-32768,32767], and should
  /// be applied in <em>addition</em> to the header gain.
  /// On error, no value is returned, and the previous
  /// contents remain unchanged.
  /// \return 0 on success, or a negative value on error.
  /// \retval #OP_FALSE There was no track gain available in the given tags.
  int opus_tags_get_track_gain(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Int> _gain_q8,
  ) {
    return _opus_tags_get_track_gain(
      _tags,
      _gain_q8,
    );
  }

  late final _opus_tags_get_track_gainPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_get_track_gain>>(
          'opus_tags_get_track_gain');
  late final _opus_tags_get_track_gain = _opus_tags_get_track_gainPtr
      .asFunction<DartOpus_tags_get_track_gain>(isLeaf: true);

  /// Clears the #OpusTags structure.
  /// This should be called on an #OpusTags structure after it is no longer
  /// needed.
  /// It will free all memory used by the structure members.
  /// \param _tags The #OpusTags structure to clear.
  void opus_tags_clear(
    ffi.Pointer<OpusTags> _tags,
  ) {
    return _opus_tags_clear(
      _tags,
    );
  }

  late final _opus_tags_clearPtr =
      _lookup<ffi.NativeFunction<NativeOpus_tags_clear>>('opus_tags_clear');
  late final _opus_tags_clear =
      _opus_tags_clearPtr.asFunction<DartOpus_tags_clear>(isLeaf: true);

  /// Check if \a _comment is an instance of a \a _tag_name tag.
  /// \see opus_tagncompare
  /// \param _tag_name A NUL-terminated, case-insensitive, ASCII string containing
  /// the name of the tag to check for (without the terminating
  /// '=' character).
  /// \param _comment  The comment string to check.
  /// \return An integer less than, equal to, or greater than zero if \a _comment
  /// is found respectively, to be less than, to match, or be greater
  /// than a "tag=value" string whose tag matches \a _tag_name.
  int opus_tagcompare(
    ffi.Pointer<ffi.Char> _tag_name,
    ffi.Pointer<ffi.Char> _comment,
  ) {
    return _opus_tagcompare(
      _tag_name,
      _comment,
    );
  }

  late final _opus_tagcomparePtr =
      _lookup<ffi.NativeFunction<NativeOpus_tagcompare>>('opus_tagcompare');
  late final _opus_tagcompare =
      _opus_tagcomparePtr.asFunction<DartOpus_tagcompare>(isLeaf: true);

  /// Check if \a _comment is an instance of a \a _tag_name tag.
  /// This version is slightly more efficient than opus_tagcompare() if the length
  /// of the tag name is already known (e.g., because it is a constant).
  /// \see opus_tagcompare
  /// \param _tag_name A case-insensitive ASCII string containing the name of the
  /// tag to check for (without the terminating '=' character).
  /// \param _tag_len  The number of characters in the tag name.
  /// This must be non-negative.
  /// \param _comment  The comment string to check.
  /// \return An integer less than, equal to, or greater than zero if \a _comment
  /// is found respectively, to be less than, to match, or be greater
  /// than a "tag=value" string whose tag matches the first \a _tag_len
  /// characters of \a _tag_name.
  int opus_tagncompare(
    ffi.Pointer<ffi.Char> _tag_name,
    int _tag_len,
    ffi.Pointer<ffi.Char> _comment,
  ) {
    return _opus_tagncompare(
      _tag_name,
      _tag_len,
      _comment,
    );
  }

  late final _opus_tagncomparePtr =
      _lookup<ffi.NativeFunction<NativeOpus_tagncompare>>('opus_tagncompare');
  late final _opus_tagncompare =
      _opus_tagncomparePtr.asFunction<DartOpus_tagncompare>(isLeaf: true);

  /// Parse a single METADATA_BLOCK_PICTURE tag.
  /// This decodes the BASE64-encoded content of the tag and returns a structure
  /// with the MIME type, description, image parameters (if known), and the
  /// compressed image data.
  /// If the MIME type indicates the presence of an image format we recognize
  /// (JPEG, PNG, or GIF) and the actual image data contains the magic signature
  /// associated with that format, then the OpusPictureTag::format field will be
  /// set to the corresponding format.
  /// This is provided as a convenience to avoid requiring applications to parse
  /// the MIME type and/or do their own format detection for the commonly used
  /// formats.
  /// In this case, we also attempt to extract the image parameters directly from
  /// the image data (overriding any that were present in the tag, which the
  /// specification says applications are not meant to rely on).
  /// The application must still provide its own support for actually decoding the
  /// image data and, if applicable, retrieving that data from URLs.
  /// \param[out] _pic Returns the parsed picture data.
  /// No sanitation is done on the type, MIME type, or
  /// description fields, so these might return invalid values.
  /// The contents of this structure are left unmodified on
  /// failure.
  /// \param      _tag The METADATA_BLOCK_PICTURE tag contents.
  /// The leading "METADATA_BLOCK_PICTURE=" portion is optional,
  /// to allow the function to be used on either directly on the
  /// values in OpusTags::user_comments or on the return value
  /// of opus_tags_query().
  /// \return 0 on success or a negative value on error.
  /// \retval #OP_ENOTFORMAT The METADATA_BLOCK_PICTURE contents were not valid.
  /// \retval #OP_EFAULT     There was not enough memory to store the picture tag
  /// contents.
  int opus_picture_tag_parse(
    ffi.Pointer<OpusPictureTag> _pic,
    ffi.Pointer<ffi.Char> _tag,
  ) {
    return _opus_picture_tag_parse(
      _pic,
      _tag,
    );
  }

  late final _opus_picture_tag_parsePtr =
      _lookup<ffi.NativeFunction<NativeOpus_picture_tag_parse>>(
          'opus_picture_tag_parse');
  late final _opus_picture_tag_parse = _opus_picture_tag_parsePtr
      .asFunction<DartOpus_picture_tag_parse>(isLeaf: true);

  /// Initializes an #OpusPictureTag structure.
  /// This should be called on a freshly allocated #OpusPictureTag structure
  /// before attempting to use it.
  /// \param _pic The #OpusPictureTag structure to initialize.
  void opus_picture_tag_init(
    ffi.Pointer<OpusPictureTag> _pic,
  ) {
    return _opus_picture_tag_init(
      _pic,
    );
  }

  late final _opus_picture_tag_initPtr =
      _lookup<ffi.NativeFunction<NativeOpus_picture_tag_init>>(
          'opus_picture_tag_init');
  late final _opus_picture_tag_init = _opus_picture_tag_initPtr
      .asFunction<DartOpus_picture_tag_init>(isLeaf: true);

  /// Clears the #OpusPictureTag structure.
  /// This should be called on an #OpusPictureTag structure after it is no longer
  /// needed.
  /// It will free all memory used by the structure members.
  /// \param _pic The #OpusPictureTag structure to clear.
  void opus_picture_tag_clear(
    ffi.Pointer<OpusPictureTag> _pic,
  ) {
    return _opus_picture_tag_clear(
      _pic,
    );
  }

  late final _opus_picture_tag_clearPtr =
      _lookup<ffi.NativeFunction<NativeOpus_picture_tag_clear>>(
          'opus_picture_tag_clear');
  late final _opus_picture_tag_clear = _opus_picture_tag_clearPtr
      .asFunction<DartOpus_picture_tag_clear>(isLeaf: true);

  /// Initializes an #OpusServerInfo structure.
  /// All fields are set as if the corresponding header was not available.
  /// \param _info The #OpusServerInfo structure to initialize.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  void opus_server_info_init(
    ffi.Pointer<OpusServerInfo> _info,
  ) {
    return _opus_server_info_init(
      _info,
    );
  }

  late final _opus_server_info_initPtr =
      _lookup<ffi.NativeFunction<NativeOpus_server_info_init>>(
          'opus_server_info_init');
  late final _opus_server_info_init = _opus_server_info_initPtr
      .asFunction<DartOpus_server_info_init>(isLeaf: true);

  /// Clears the #OpusServerInfo structure.
  /// This should be called on an #OpusServerInfo structure after it is no longer
  /// needed.
  /// It will free all memory used by the structure members.
  /// \param _info The #OpusServerInfo structure to clear.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  void opus_server_info_clear(
    ffi.Pointer<OpusServerInfo> _info,
  ) {
    return _opus_server_info_clear(
      _info,
    );
  }

  late final _opus_server_info_clearPtr =
      _lookup<ffi.NativeFunction<NativeOpus_server_info_clear>>(
          'opus_server_info_clear');
  late final _opus_server_info_clear = _opus_server_info_clearPtr
      .asFunction<DartOpus_server_info_clear>(isLeaf: true);

  /// Opens a stream with <code>fopen()</code> and fills in a set of callbacks
  /// that can be used to access it.
  /// This is useful to avoid writing your own portable 64-bit seeking wrappers,
  /// and also avoids cross-module linking issues on Windows, where a
  /// <code>FILE *</code> must be accessed by routines defined in the same module
  /// that opened it.
  /// \param[out] _cb   The callbacks to use for this file.
  /// If there is an error opening the file, nothing will be
  /// filled in here.
  /// \param      _path The path to the file to open.
  /// On Windows, this string must be UTF-8 (to allow access to
  /// files whose names cannot be represented in the current
  /// MBCS code page).
  /// All other systems use the native character encoding.
  /// \param      _mode The mode to open the file in.
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_fopen(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode,
  ) {
    return _op_fopen(
      _cb,
      _path,
      _mode,
    );
  }

  late final _op_fopenPtr =
      _lookup<ffi.NativeFunction<NativeOp_fopen>>('op_fopen');
  late final _op_fopen = _op_fopenPtr.asFunction<DartOp_fopen>(isLeaf: true);

  /// Opens a stream with <code>fdopen()</code> and fills in a set of callbacks
  /// that can be used to access it.
  /// This is useful to avoid writing your own portable 64-bit seeking wrappers,
  /// and also avoids cross-module linking issues on Windows, where a
  /// <code>FILE *</code> must be accessed by routines defined in the same module
  /// that opened it.
  /// \param[out] _cb   The callbacks to use for this file.
  /// If there is an error opening the file, nothing will be
  /// filled in here.
  /// \param      _fd   The file descriptor to open.
  /// \param      _mode The mode to open the file in.
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_fdopen(
    ffi.Pointer<OpusFileCallbacks> _cb,
    int _fd,
    ffi.Pointer<ffi.Char> _mode,
  ) {
    return _op_fdopen(
      _cb,
      _fd,
      _mode,
    );
  }

  late final _op_fdopenPtr =
      _lookup<ffi.NativeFunction<NativeOp_fdopen>>('op_fdopen');
  late final _op_fdopen = _op_fdopenPtr.asFunction<DartOp_fdopen>(isLeaf: true);

  /// Opens a stream with <code>freopen()</code> and fills in a set of callbacks
  /// that can be used to access it.
  /// This is useful to avoid writing your own portable 64-bit seeking wrappers,
  /// and also avoids cross-module linking issues on Windows, where a
  /// <code>FILE *</code> must be accessed by routines defined in the same module
  /// that opened it.
  /// \param[out] _cb     The callbacks to use for this file.
  /// If there is an error opening the file, nothing will be
  /// filled in here.
  /// \param      _path   The path to the file to open.
  /// On Windows, this string must be UTF-8 (to allow access
  /// to files whose names cannot be represented in the
  /// current MBCS code page).
  /// All other systems use the native character encoding.
  /// \param      _mode   The mode to open the file in.
  /// \param      _stream A stream previously returned by op_fopen(), op_fdopen(),
  /// or op_freopen().
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_freopen(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode,
    ffi.Pointer<ffi.Void> _stream,
  ) {
    return _op_freopen(
      _cb,
      _path,
      _mode,
      _stream,
    );
  }

  late final _op_freopenPtr =
      _lookup<ffi.NativeFunction<NativeOp_freopen>>('op_freopen');
  late final _op_freopen =
      _op_freopenPtr.asFunction<DartOp_freopen>(isLeaf: true);

  /// Creates a stream that reads from the given block of memory.
  /// This block of memory must contain the complete stream to decode.
  /// This is useful for caching small streams (e.g., sound effects) in RAM.
  /// \param[out] _cb   The callbacks to use for this stream.
  /// If there is an error creating the stream, nothing will be
  /// filled in here.
  /// \param      _data The block of memory to read from.
  /// \param      _size The size of the block of memory.
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_mem_stream_create(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size,
  ) {
    return _op_mem_stream_create(
      _cb,
      _data,
      _size,
    );
  }

  late final _op_mem_stream_createPtr =
      _lookup<ffi.NativeFunction<NativeOp_mem_stream_create>>(
          'op_mem_stream_create');
  late final _op_mem_stream_create = _op_mem_stream_createPtr
      .asFunction<DartOp_mem_stream_create>(isLeaf: true);

  /// Creates a stream that reads from the given URL.
  /// This function behaves identically to op_url_stream_create(), except that it
  /// takes a va_list instead of a variable number of arguments.
  /// It does not call the <code>va_end</code> macro, and because it invokes the
  /// <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \param[out]    _cb  The callbacks to use for this stream.
  /// If there is an error creating the stream, nothing will
  /// be filled in here.
  /// \param         _url The URL to read from.
  /// Currently only the <file:>, <http:>, and <https:>
  /// schemes are supported.
  /// Both <http:> and <https:> may be disabled at compile
  /// time, in which case opening such URLs will always fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped, with
  /// internationalized domain names encoded in punycode,
  /// before passing them to this function.
  /// \param[in,out] _ap  A list of the \ref url_options "optional flags" to use.
  /// This is a variable-length list of options terminated
  /// with <code>NULL</code>.
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_url_stream_vcreate(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _url,
    va_list _ap,
  ) {
    return _op_url_stream_vcreate(
      _cb,
      _url,
      _ap,
    );
  }

  late final _op_url_stream_vcreatePtr =
      _lookup<ffi.NativeFunction<NativeOp_url_stream_vcreate>>(
          'op_url_stream_vcreate');
  late final _op_url_stream_vcreate = _op_url_stream_vcreatePtr
      .asFunction<DartOp_url_stream_vcreate>(isLeaf: true);

  /// Creates a stream that reads from the given URL.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \param[out] _cb  The callbacks to use for this stream.
  /// If there is an error creating the stream, nothing will be
  /// filled in here.
  /// \param      _url The URL to read from.
  /// Currently only the <file:>, <http:>, and <https:> schemes
  /// are supported.
  /// Both <http:> and <https:> may be disabled at compile time,
  /// in which case opening such URLs will always fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped, with
  /// internationalized domain names encoded in punycode, before
  /// passing them to this function.
  /// \param      ...  The \ref url_options "optional flags" to use.
  /// This is a variable-length list of options terminated with
  /// <code>NULL</code>.
  /// \return A stream handle to use with the callbacks, or <code>NULL</code> on
  /// error.
  ffi.Pointer<ffi.Void> op_url_stream_create(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _url,
  ) {
    return _op_url_stream_create(
      _cb,
      _url,
    );
  }

  late final _op_url_stream_createPtr =
      _lookup<ffi.NativeFunction<NativeOp_url_stream_create>>(
          'op_url_stream_create');
  late final _op_url_stream_create = _op_url_stream_createPtr
      .asFunction<DartOp_url_stream_create>(isLeaf: true);

  /// Test to see if this is an Opus stream.
  /// For good results, you will need at least 57 bytes (for a pure Opus-only
  /// stream).
  /// Something like 512 bytes will give more reliable results for multiplexed
  /// streams.
  /// This function is meant to be a quick-rejection filter.
  /// Its purpose is not to guarantee that a stream is a valid Opus stream, but to
  /// ensure that it looks enough like Opus that it isn't going to be recognized
  /// as some other format (except possibly an Opus stream that is also
  /// multiplexed with other codecs, such as video).
  /// \param[out] _head     The parsed ID header contents.
  /// You may pass <code>NULL</code> if you do not need
  /// this information.
  /// If the function fails, the contents of this structure
  /// remain untouched.
  /// \param _initial_data  An initial buffer of data from the start of the
  /// stream.
  /// \param _initial_bytes The number of bytes in \a _initial_data.
  /// \return 0 if the data appears to be Opus, or a negative value on error.
  /// \retval #OP_FALSE      There was not enough data to tell if this was an Opus
  /// stream or not.
  /// \retval #OP_EFAULT     An internal memory allocation failed.
  /// \retval #OP_EIMPL      The stream used a feature that is not implemented,
  /// such as an unsupported channel family.
  /// \retval #OP_ENOTFORMAT If the data did not contain a recognizable ID
  /// header for an Opus stream.
  /// \retval #OP_EVERSION   If the version field signaled a version this library
  /// does not know how to parse.
  /// \retval #OP_EBADHEADER The ID header was not properly formatted or contained
  /// illegal values.
  int op_test(
    ffi.Pointer<OpusHead> _head,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    int _initial_bytes,
  ) {
    return _op_test(
      _head,
      _initial_data,
      _initial_bytes,
    );
  }

  late final _op_testPtr =
      _lookup<ffi.NativeFunction<NativeOp_test>>('op_test');
  late final _op_test = _op_testPtr.asFunction<DartOp_test>(isLeaf: true);

  /// Open a stream from the given file path.
  /// \param      _path  The path to the file to open.
  /// \param[out] _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// The failure code will be #OP_EFAULT if the file could not
  /// be opened, or one of the other failure codes from
  /// op_open_callbacks() otherwise.
  /// \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_open_file(
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_open_file(
      _path,
      _error,
    );
  }

  late final _op_open_filePtr =
      _lookup<ffi.NativeFunction<NativeOp_open_file>>('op_open_file');
  late final _op_open_file =
      _op_open_filePtr.asFunction<DartOp_open_file>(isLeaf: true);

  /// Open a stream from a memory buffer.
  /// \param      _data  The memory buffer to open.
  /// \param      _size  The number of bytes in the buffer.
  /// \param[out] _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// See op_open_callbacks() for a full list of failure codes.
  /// \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_open_memory(
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_open_memory(
      _data,
      _size,
      _error,
    );
  }

  late final _op_open_memoryPtr =
      _lookup<ffi.NativeFunction<NativeOp_open_memory>>('op_open_memory');
  late final _op_open_memory =
      _op_open_memoryPtr.asFunction<DartOp_open_memory>(isLeaf: true);

  /// Open a stream from a URL.
  /// This function behaves identically to op_open_url(), except that it
  /// takes a va_list instead of a variable number of arguments.
  /// It does not call the <code>va_end</code> macro, and because it invokes the
  /// <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \param         _url   The URL to open.
  /// Currently only the <file:>, <http:>, and <https:>
  /// schemes are supported.
  /// Both <http:> and <https:> may be disabled at compile
  /// time, in which case opening such URLs will always
  /// fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped,
  /// with internationalized domain names encoded in
  /// punycode, before passing them to this function.
  /// \param[out]    _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want
  /// the failure code.
  /// See op_open_callbacks() for a full list of failure
  /// codes.
  /// \param[in,out] _ap    A list of the \ref url_options "optional flags" to
  /// use.
  /// This is a variable-length list of options terminated
  /// with <code>NULL</code>.
  /// \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_vopen_url(
    ffi.Pointer<ffi.Char> _url,
    ffi.Pointer<ffi.Int> _error,
    va_list _ap,
  ) {
    return _op_vopen_url(
      _url,
      _error,
      _ap,
    );
  }

  late final _op_vopen_urlPtr =
      _lookup<ffi.NativeFunction<NativeOp_vopen_url>>('op_vopen_url');
  late final _op_vopen_url =
      _op_vopen_urlPtr.asFunction<DartOp_vopen_url>(isLeaf: true);

  /// Open a stream from a URL.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \param      _url   The URL to open.
  /// Currently only the <file:>, <http:>, and <https:> schemes
  /// are supported.
  /// Both <http:> and <https:> may be disabled at compile
  /// time, in which case opening such URLs will always fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped, with
  /// internationalized domain names encoded in punycode,
  /// before passing them to this function.
  /// \param[out] _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// See op_open_callbacks() for a full list of failure codes.
  /// \param      ...    The \ref url_options "optional flags" to use.
  /// This is a variable-length list of options terminated with
  /// <code>NULL</code>.
  /// \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_open_url(
    ffi.Pointer<ffi.Char> _url,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_open_url(
      _url,
      _error,
    );
  }

  late final _op_open_urlPtr =
      _lookup<ffi.NativeFunction<NativeOp_open_url>>('op_open_url');
  late final _op_open_url =
      _op_open_urlPtr.asFunction<DartOp_open_url>(isLeaf: true);

  /// Open a stream using the given set of callbacks to access it.
  /// \param _stream        The stream to read from (e.g., a <code>FILE *</code>).
  /// This value will be passed verbatim as the first
  /// argument to all of the callbacks.
  /// \param _cb            The callbacks with which to access the stream.
  /// \ref op_read_func "read()" must be implemented.
  /// \ref op_seek_func "seek()" and \ref op_tell_func
  /// "tell()" may be <code>NULL</code>, or may always
  /// return -1 to indicate a stream is unseekable, but if
  /// \ref op_seek_func "seek()" is implemented and
  /// succeeds on a particular stream, then \ref
  /// op_tell_func "tell()" must also.
  /// \ref op_close_func "close()" may be <code>NULL</code>,
  /// but if it is not, it will be called when the \c
  /// OggOpusFile is destroyed by op_free().
  /// It will not be called if op_open_callbacks() fails
  /// with an error.
  /// \param _initial_data  An initial buffer of data from the start of the
  /// stream.
  /// Applications can read some number of bytes from the
  /// start of the stream to help identify this as an Opus
  /// stream, and then provide them here to allow the
  /// stream to be opened, even if it is unseekable.
  /// \param _initial_bytes The number of bytes in \a _initial_data.
  /// If the stream is seekable, its current position (as
  /// reported by \ref op_tell_func "tell()" at the start
  /// of this function) must be equal to \a _initial_bytes.
  /// Otherwise, seeking to absolute positions will
  /// generate inconsistent results.
  /// \param[out] _error    Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want
  /// the failure code.
  /// The failure code will be one of
  /// <dl>
  /// <dt>#OP_EREAD</dt>
  /// <dd>An underlying read, seek, or tell operation
  /// failed when it should have succeeded, or we failed
  /// to find data in the stream we had seen before.</dd>
  /// <dt>#OP_EFAULT</dt>
  /// <dd>There was a memory allocation failure, or an
  /// internal library error.</dd>
  /// <dt>#OP_EIMPL</dt>
  /// <dd>The stream used a feature that is not
  /// implemented, such as an unsupported channel
  /// family.</dd>
  /// <dt>#OP_EINVAL</dt>
  /// <dd>\ref op_seek_func "seek()" was implemented and
  /// succeeded on this source, but \ref op_tell_func
  /// "tell()" did not, or the starting position
  /// indicator was not equal to \a _initial_bytes.</dd>
  /// <dt>#OP_ENOTFORMAT</dt>
  /// <dd>The stream contained a link that did not have
  /// any logical Opus streams in it.</dd>
  /// <dt>#OP_EBADHEADER</dt>
  /// <dd>A required header packet was not properly
  /// formatted, contained illegal values, or was missing
  /// altogether.</dd>
  /// <dt>#OP_EVERSION</dt>
  /// <dd>An ID header contained an unrecognized version
  /// number.</dd>
  /// <dt>#OP_EBADLINK</dt>
  /// <dd>We failed to find data we had seen before after
  /// seeking.</dd>
  /// <dt>#OP_EBADTIMESTAMP</dt>
  /// <dd>The first or last timestamp in a link failed
  /// basic validity checks.</dd>
  /// </dl>
  /// \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
  /// <tt>libopusfile</tt> does <em>not</em> take ownership of the stream
  /// if the call fails.
  /// The calling application is responsible for closing the stream if
  /// this call returns an error.
  ffi.Pointer<OggOpusFile> op_open_callbacks(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    int _initial_bytes,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_open_callbacks(
      _stream,
      _cb,
      _initial_data,
      _initial_bytes,
      _error,
    );
  }

  late final _op_open_callbacksPtr =
      _lookup<ffi.NativeFunction<NativeOp_open_callbacks>>('op_open_callbacks');
  late final _op_open_callbacks =
      _op_open_callbacksPtr.asFunction<DartOp_open_callbacks>(isLeaf: true);

  /// Partially open a stream from the given file path.
  /// \see op_test_callbacks
  /// \param      _path  The path to the file to open.
  /// \param[out] _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// The failure code will be #OP_EFAULT if the file could not
  /// be opened, or one of the other failure codes from
  /// op_open_callbacks() otherwise.
  /// \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_test_file(
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_test_file(
      _path,
      _error,
    );
  }

  late final _op_test_filePtr =
      _lookup<ffi.NativeFunction<NativeOp_test_file>>('op_test_file');
  late final _op_test_file =
      _op_test_filePtr.asFunction<DartOp_test_file>(isLeaf: true);

  /// Partially open a stream from a memory buffer.
  /// \see op_test_callbacks
  /// \param      _data  The memory buffer to open.
  /// \param      _size  The number of bytes in the buffer.
  /// \param[out] _error Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// See op_open_callbacks() for a full list of failure codes.
  /// \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_test_memory(
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_test_memory(
      _data,
      _size,
      _error,
    );
  }

  late final _op_test_memoryPtr =
      _lookup<ffi.NativeFunction<NativeOp_test_memory>>('op_test_memory');
  late final _op_test_memory =
      _op_test_memoryPtr.asFunction<DartOp_test_memory>(isLeaf: true);

  /// Partially open a stream from a URL.
  /// This function behaves identically to op_test_url(), except that it
  /// takes a va_list instead of a variable number of arguments.
  /// It does not call the <code>va_end</code> macro, and because it invokes the
  /// <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \see op_test_url
  /// \see op_test_callbacks
  /// \param         _url    The URL to open.
  /// Currently only the <file:>, <http:>, and <https:>
  /// schemes are supported.
  /// Both <http:> and <https:> may be disabled at compile
  /// time, in which case opening such URLs will always
  /// fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped,
  /// with internationalized domain names encoded in
  /// punycode, before passing them to this function.
  /// \param[out]    _error  Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want
  /// the failure code.
  /// See op_open_callbacks() for a full list of failure
  /// codes.
  /// \param[in,out] _ap     A list of the \ref url_options "optional flags" to
  /// use.
  /// This is a variable-length list of options terminated
  /// with <code>NULL</code>.
  /// \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_vtest_url(
    ffi.Pointer<ffi.Char> _url,
    ffi.Pointer<ffi.Int> _error,
    va_list _ap,
  ) {
    return _op_vtest_url(
      _url,
      _error,
      _ap,
    );
  }

  late final _op_vtest_urlPtr =
      _lookup<ffi.NativeFunction<NativeOp_vtest_url>>('op_vtest_url');
  late final _op_vtest_url =
      _op_vtest_urlPtr.asFunction<DartOp_vtest_url>(isLeaf: true);

  /// Partially open a stream from a URL.
  /// \note If you use this function, you must link against <tt>libopusurl</tt>.
  /// \see op_test_callbacks
  /// \param      _url    The URL to open.
  /// Currently only the <file:>, <http:>, and <https:>
  /// schemes are supported.
  /// Both <http:> and <https:> may be disabled at compile
  /// time, in which case opening such URLs will always fail.
  /// Currently this only supports URIs.
  /// IRIs should be converted to UTF-8 and URL-escaped, with
  /// internationalized domain names encoded in punycode,
  /// before passing them to this function.
  /// \param[out] _error  Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want the
  /// failure code.
  /// See op_open_callbacks() for a full list of failure
  /// codes.
  /// \param      ...     The \ref url_options "optional flags" to use.
  /// This is a variable-length list of options terminated
  /// with <code>NULL</code>.
  /// \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
  ffi.Pointer<OggOpusFile> op_test_url(
    ffi.Pointer<ffi.Char> _url,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_test_url(
      _url,
      _error,
    );
  }

  late final _op_test_urlPtr =
      _lookup<ffi.NativeFunction<NativeOp_test_url>>('op_test_url');
  late final _op_test_url =
      _op_test_urlPtr.asFunction<DartOp_test_url>(isLeaf: true);

  /// Partially open a stream using the given set of callbacks to access it.
  /// This tests for Opusness and loads the headers for the first link.
  /// It does not seek (although it tests for seekability).
  /// You can query a partially open stream for the few pieces of basic
  /// information returned by op_serialno(), op_channel_count(), op_head(), and
  /// op_tags() (but only for the first link).
  /// You may also determine if it is seekable via a call to op_seekable().
  /// You cannot read audio from the stream, seek, get the size or duration,
  /// get information from links other than the first one, or even get the total
  /// number of links until you finish opening the stream with op_test_open().
  /// If you do not need to do any of these things, you can dispose of it with
  /// op_free() instead.
  ///
  /// This function is provided mostly to simplify porting existing code that used
  /// <tt>libvorbisfile</tt>.
  /// For new code, you are likely better off using op_test() instead, which
  /// is less resource-intensive, requires less data to succeed, and imposes a
  /// hard limit on the amount of data it examines (important for unseekable
  /// streams, where all such data must be buffered until you are sure of the
  /// stream type).
  /// \param _stream        The stream to read from (e.g., a <code>FILE *</code>).
  /// This value will be passed verbatim as the first
  /// argument to all of the callbacks.
  /// \param _cb            The callbacks with which to access the stream.
  /// \ref op_read_func "read()" must be implemented.
  /// \ref op_seek_func "seek()" and \ref op_tell_func
  /// "tell()" may be <code>NULL</code>, or may always
  /// return -1 to indicate a stream is unseekable, but if
  /// \ref op_seek_func "seek()" is implemented and
  /// succeeds on a particular stream, then \ref
  /// op_tell_func "tell()" must also.
  /// \ref op_close_func "close()" may be <code>NULL</code>,
  /// but if it is not, it will be called when the \c
  /// OggOpusFile is destroyed by op_free().
  /// It will not be called if op_open_callbacks() fails
  /// with an error.
  /// \param _initial_data  An initial buffer of data from the start of the
  /// stream.
  /// Applications can read some number of bytes from the
  /// start of the stream to help identify this as an Opus
  /// stream, and then provide them here to allow the
  /// stream to be tested more thoroughly, even if it is
  /// unseekable.
  /// \param _initial_bytes The number of bytes in \a _initial_data.
  /// If the stream is seekable, its current position (as
  /// reported by
  /// \ref op_tell_func "tell()" at the start of this
  /// function) must be equal to \a _initial_bytes.
  /// Otherwise, seeking to absolute positions will
  /// generate inconsistent results.
  /// \param[out] _error    Returns 0 on success, or a failure code on error.
  /// You may pass in <code>NULL</code> if you don't want
  /// the failure code.
  /// See op_open_callbacks() for a full list of failure
  /// codes.
  /// \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
  /// <tt>libopusfile</tt> does <em>not</em> take ownership of the stream
  /// if the call fails.
  /// The calling application is responsible for closing the stream if
  /// this call returns an error.
  ffi.Pointer<OggOpusFile> op_test_callbacks(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    int _initial_bytes,
    ffi.Pointer<ffi.Int> _error,
  ) {
    return _op_test_callbacks(
      _stream,
      _cb,
      _initial_data,
      _initial_bytes,
      _error,
    );
  }

  late final _op_test_callbacksPtr =
      _lookup<ffi.NativeFunction<NativeOp_test_callbacks>>('op_test_callbacks');
  late final _op_test_callbacks =
      _op_test_callbacksPtr.asFunction<DartOp_test_callbacks>(isLeaf: true);

  /// Finish opening a stream partially opened with op_test_callbacks() or one of
  /// the associated convenience functions.
  /// If this function fails, you are still responsible for freeing the
  /// \c OggOpusFile with op_free().
  /// \param _of The \c OggOpusFile to finish opening.
  /// \return 0 on success, or a negative value on error.
  /// \retval #OP_EREAD         An underlying read, seek, or tell operation failed
  /// when it should have succeeded.
  /// \retval #OP_EFAULT        There was a memory allocation failure, or an
  /// internal library error.
  /// \retval #OP_EIMPL         The stream used a feature that is not implemented,
  /// such as an unsupported channel family.
  /// \retval #OP_EINVAL        The stream was not partially opened with
  /// op_test_callbacks() or one of the associated
  /// convenience functions.
  /// \retval #OP_ENOTFORMAT    The stream contained a link that did not have any
  /// logical Opus streams in it.
  /// \retval #OP_EBADHEADER    A required header packet was not properly
  /// formatted, contained illegal values, or was
  /// missing altogether.
  /// \retval #OP_EVERSION      An ID header contained an unrecognized version
  /// number.
  /// \retval #OP_EBADLINK      We failed to find data we had seen before after
  /// seeking.
  /// \retval #OP_EBADTIMESTAMP The first or last timestamp in a link failed basic
  /// validity checks.
  int op_test_open(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_test_open(
      _of,
    );
  }

  late final _op_test_openPtr =
      _lookup<ffi.NativeFunction<NativeOp_test_open>>('op_test_open');
  late final _op_test_open =
      _op_test_openPtr.asFunction<DartOp_test_open>(isLeaf: true);

  /// Release all memory used by an \c OggOpusFile.
  /// \param _of The \c OggOpusFile to free.
  void op_free(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_free(
      _of,
    );
  }

  late final _op_freePtr =
      _lookup<ffi.NativeFunction<NativeOp_free>>('op_free');
  late final _op_free = _op_freePtr.asFunction<DartOp_free>(isLeaf: true);

  /// Returns whether or not the stream being read is seekable.
  /// This is true if
  /// <ol>
  /// <li>The \ref op_seek_func "seek()" and \ref op_tell_func "tell()"
  /// callbacks are both non-<code>NULL</code>,</li>
  /// <li>The \ref op_seek_func "seek()" callback was successfully executed at
  /// least once, and</li>
  /// <li>The \ref op_tell_func "tell()" callback was successfully able to report
  /// the position indicator afterwards.</li>
  /// </ol>
  /// This function may be called on partially-opened streams.
  /// \param _of The \c OggOpusFile whose seekable status is to be returned.
  /// \return A non-zero value if seekable, and 0 if unseekable.
  int op_seekable(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_seekable(
      _of,
    );
  }

  late final _op_seekablePtr =
      _lookup<ffi.NativeFunction<NativeOp_seekable>>('op_seekable');
  late final _op_seekable =
      _op_seekablePtr.asFunction<DartOp_seekable>(isLeaf: true);

  /// Returns the number of links in this chained stream.
  /// This function may be called on partially-opened streams, but it will always
  /// return 1.
  /// The actual number of links is not known until the stream is fully opened.
  /// \param _of The \c OggOpusFile from which to retrieve the link count.
  /// \return For fully-open seekable streams, this returns the total number of
  /// links in the whole stream, which will be at least 1.
  /// For partially-open or unseekable streams, this always returns 1.
  int op_link_count(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_link_count(
      _of,
    );
  }

  late final _op_link_countPtr =
      _lookup<ffi.NativeFunction<NativeOp_link_count>>('op_link_count');
  late final _op_link_count =
      _op_link_countPtr.asFunction<DartOp_link_count>(isLeaf: true);

  /// Get the serial number of the given link in a (possibly-chained) Ogg Opus
  /// stream.
  /// This function may be called on partially-opened streams, but it will always
  /// return the serial number of the Opus stream in the first link.
  /// \param _of The \c OggOpusFile from which to retrieve the serial number.
  /// \param _li The index of the link whose serial number should be retrieved.
  /// Use a negative number to get the serial number of the current
  /// link.
  /// \return The serial number of the given link.
  /// If \a _li is greater than the total number of links, this returns
  /// the serial number of the last link.
  /// If the stream is not seekable, this always returns the serial number
  /// of the current link.
  int op_serialno(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_serialno(
      _of,
      _li,
    );
  }

  late final _op_serialnoPtr =
      _lookup<ffi.NativeFunction<NativeOp_serialno>>('op_serialno');
  late final _op_serialno =
      _op_serialnoPtr.asFunction<DartOp_serialno>(isLeaf: true);

  /// Get the channel count of the given link in a (possibly-chained) Ogg Opus
  /// stream.
  /// This is equivalent to <code>op_head(_of,_li)->channel_count</code>, but
  /// is provided for convenience.
  /// This function may be called on partially-opened streams, but it will always
  /// return the channel count of the Opus stream in the first link.
  /// \param _of The \c OggOpusFile from which to retrieve the channel count.
  /// \param _li The index of the link whose channel count should be retrieved.
  /// Use a negative number to get the channel count of the current
  /// link.
  /// \return The channel count of the given link.
  /// If \a _li is greater than the total number of links, this returns
  /// the channel count of the last link.
  /// If the stream is not seekable, this always returns the channel count
  /// of the current link.
  int op_channel_count(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_channel_count(
      _of,
      _li,
    );
  }

  late final _op_channel_countPtr =
      _lookup<ffi.NativeFunction<NativeOp_channel_count>>('op_channel_count');
  late final _op_channel_count =
      _op_channel_countPtr.asFunction<DartOp_channel_count>(isLeaf: true);

  /// Get the total (compressed) size of the stream, or of an individual link in
  /// a (possibly-chained) Ogg Opus stream, including all headers and Ogg muxing
  /// overhead.
  /// \warning If the Opus stream (or link) is concurrently multiplexed with other
  /// logical streams (e.g., video), this returns the size of the entire stream
  /// (or link), not just the number of bytes in the first logical Opus stream.
  /// Returning the latter would require scanning the entire file.
  /// \param _of The \c OggOpusFile from which to retrieve the compressed size.
  /// \param _li The index of the link whose compressed size should be computed.
  /// Use a negative number to get the compressed size of the entire
  /// stream.
  /// \return The compressed size of the entire stream if \a _li is negative, the
  /// compressed size of link \a _li if it is non-negative, or a negative
  /// value on error.
  /// The compressed size of the entire stream may be smaller than that
  /// of the underlying stream if trailing garbage was detected in the
  /// file.
  /// \retval #OP_EINVAL The stream is not seekable (so we can't know the length),
  /// \a _li wasn't less than the total number of links in
  /// the stream, or the stream was only partially open.
  int op_raw_total(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_raw_total(
      _of,
      _li,
    );
  }

  late final _op_raw_totalPtr =
      _lookup<ffi.NativeFunction<NativeOp_raw_total>>('op_raw_total');
  late final _op_raw_total =
      _op_raw_totalPtr.asFunction<DartOp_raw_total>(isLeaf: true);

  /// Get the total PCM length (number of samples at 48 kHz) of the stream, or of
  /// an individual link in a (possibly-chained) Ogg Opus stream.
  /// Users looking for <code>op_time_total()</code> should use op_pcm_total()
  /// instead.
  /// Because timestamps in Opus are fixed at 48 kHz, there is no need for a
  /// separate function to convert this to seconds (and leaving it out avoids
  /// introducing floating point to the API, for those that wish to avoid it).
  /// \param _of The \c OggOpusFile from which to retrieve the PCM offset.
  /// \param _li The index of the link whose PCM length should be computed.
  /// Use a negative number to get the PCM length of the entire stream.
  /// \return The PCM length of the entire stream if \a _li is negative, the PCM
  /// length of link \a _li if it is non-negative, or a negative value on
  /// error.
  /// \retval #OP_EINVAL The stream is not seekable (so we can't know the length),
  /// \a _li wasn't less than the total number of links in
  /// the stream, or the stream was only partially open.
  int op_pcm_total(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_pcm_total(
      _of,
      _li,
    );
  }

  late final _op_pcm_totalPtr =
      _lookup<ffi.NativeFunction<NativeOp_pcm_total>>('op_pcm_total');
  late final _op_pcm_total =
      _op_pcm_totalPtr.asFunction<DartOp_pcm_total>(isLeaf: true);

  /// Get the ID header information for the given link in a (possibly chained) Ogg
  /// Opus stream.
  /// This function may be called on partially-opened streams, but it will always
  /// return the ID header information of the Opus stream in the first link.
  /// \param _of The \c OggOpusFile from which to retrieve the ID header
  /// information.
  /// \param _li The index of the link whose ID header information should be
  /// retrieved.
  /// Use a negative number to get the ID header information of the
  /// current link.
  /// For an unseekable stream, \a _li is ignored, and the ID header
  /// information for the current link is always returned, if
  /// available.
  /// \return The contents of the ID header for the given link.
  ffi.Pointer<OpusHead> op_head(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_head(
      _of,
      _li,
    );
  }

  late final _op_headPtr =
      _lookup<ffi.NativeFunction<NativeOp_head>>('op_head');
  late final _op_head = _op_headPtr.asFunction<DartOp_head>(isLeaf: true);

  /// Get the comment header information for the given link in a (possibly
  /// chained) Ogg Opus stream.
  /// This function may be called on partially-opened streams, but it will always
  /// return the tags from the Opus stream in the first link.
  /// \param _of The \c OggOpusFile from which to retrieve the comment header
  /// information.
  /// \param _li The index of the link whose comment header information should be
  /// retrieved.
  /// Use a negative number to get the comment header information of
  /// the current link.
  /// For an unseekable stream, \a _li is ignored, and the comment
  /// header information for the current link is always returned, if
  /// available.
  /// \return The contents of the comment header for the given link, or
  /// <code>NULL</code> if this is an unseekable stream that encountered
  /// an invalid link.
  ffi.Pointer<OpusTags> op_tags(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_tags(
      _of,
      _li,
    );
  }

  late final _op_tagsPtr =
      _lookup<ffi.NativeFunction<NativeOp_tags>>('op_tags');
  late final _op_tags = _op_tagsPtr.asFunction<DartOp_tags>(isLeaf: true);

  /// Retrieve the index of the current link.
  /// This is the link that produced the data most recently read by
  /// op_read_float() or its associated functions, or, after a seek, the link
  /// that the seek target landed in.
  /// Reading more data may advance the link index (even on the first read after a
  /// seek).
  /// \param _of The \c OggOpusFile from which to retrieve the current link index.
  /// \return The index of the current link on success, or a negative value on
  /// failure.
  /// For seekable streams, this is a number between 0 (inclusive) and the
  /// value returned by op_link_count() (exclusive).
  /// For unseekable streams, this value starts at 0 and increments by one
  /// each time a new link is encountered (even though op_link_count()
  /// always returns 1).
  /// \retval #OP_EINVAL The stream was only partially open.
  int op_current_link(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_current_link(
      _of,
    );
  }

  late final _op_current_linkPtr =
      _lookup<ffi.NativeFunction<NativeOp_current_link>>('op_current_link');
  late final _op_current_link =
      _op_current_linkPtr.asFunction<DartOp_current_link>(isLeaf: true);

  /// Computes the bitrate of the stream, or of an individual link in a
  /// (possibly-chained) Ogg Opus stream.
  /// The stream must be seekable to compute the bitrate.
  /// For unseekable streams, use op_bitrate_instant() to get periodic estimates.
  /// \warning If the Opus stream (or link) is concurrently multiplexed with other
  /// logical streams (e.g., video), this uses the size of the entire stream (or
  /// link) to compute the bitrate, not just the number of bytes in the first
  /// logical Opus stream.
  /// Returning the latter requires scanning the entire file, but this may be done
  /// by decoding the whole file and calling op_bitrate_instant() once at the
  /// end.
  /// Install a trivial decoding callback with op_set_decode_callback() if you
  /// wish to skip actual decoding during this process.
  /// \param _of The \c OggOpusFile from which to retrieve the bitrate.
  /// \param _li The index of the link whose bitrate should be computed.
  /// Use a negative number to get the bitrate of the whole stream.
  /// \return The bitrate on success, or a negative value on error.
  /// \retval #OP_EINVAL The stream was only partially open, the stream was not
  /// seekable, or \a _li was larger than the number of
  /// links.
  int op_bitrate(
    ffi.Pointer<OggOpusFile> _of,
    int _li,
  ) {
    return _op_bitrate(
      _of,
      _li,
    );
  }

  late final _op_bitratePtr =
      _lookup<ffi.NativeFunction<NativeOp_bitrate>>('op_bitrate');
  late final _op_bitrate =
      _op_bitratePtr.asFunction<DartOp_bitrate>(isLeaf: true);

  /// Compute the instantaneous bitrate, measured as the ratio of bits to playable
  /// samples decoded since a) the last call to op_bitrate_instant(), b) the last
  /// seek, or c) the start of playback, whichever was most recent.
  /// This will spike somewhat after a seek or at the start/end of a chain
  /// boundary, as pre-skip, pre-roll, and end-trimming causes samples to be
  /// decoded but not played.
  /// \param _of The \c OggOpusFile from which to retrieve the bitrate.
  /// \return The bitrate, in bits per second, or a negative value on error.
  /// \retval #OP_FALSE  No data has been decoded since any of the events
  /// described above.
  /// \retval #OP_EINVAL The stream was only partially open.
  int op_bitrate_instant(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_bitrate_instant(
      _of,
    );
  }

  late final _op_bitrate_instantPtr =
      _lookup<ffi.NativeFunction<NativeOp_bitrate_instant>>(
          'op_bitrate_instant');
  late final _op_bitrate_instant =
      _op_bitrate_instantPtr.asFunction<DartOp_bitrate_instant>(isLeaf: true);

  /// Obtain the current value of the position indicator for \a _of.
  /// \param _of The \c OggOpusFile from which to retrieve the position indicator.
  /// \return The byte position that is currently being read from.
  /// \retval #OP_EINVAL The stream was only partially open.
  int op_raw_tell(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_raw_tell(
      _of,
    );
  }

  late final _op_raw_tellPtr =
      _lookup<ffi.NativeFunction<NativeOp_raw_tell>>('op_raw_tell');
  late final _op_raw_tell =
      _op_raw_tellPtr.asFunction<DartOp_raw_tell>(isLeaf: true);

  /// Obtain the PCM offset of the next sample to be read.
  /// If the stream is not properly timestamped, this might not increment by the
  /// proper amount between reads, or even return monotonically increasing
  /// values.
  /// \param _of The \c OggOpusFile from which to retrieve the PCM offset.
  /// \return The PCM offset of the next sample to be read.
  /// \retval #OP_EINVAL The stream was only partially open.
  int op_pcm_tell(
    ffi.Pointer<OggOpusFile> _of,
  ) {
    return _op_pcm_tell(
      _of,
    );
  }

  late final _op_pcm_tellPtr =
      _lookup<ffi.NativeFunction<NativeOp_pcm_tell>>('op_pcm_tell');
  late final _op_pcm_tell =
      _op_pcm_tellPtr.asFunction<DartOp_pcm_tell>(isLeaf: true);

  /// Seek to a byte offset relative to the <b>compressed</b> data.
  /// This also scans packets to update the PCM cursor.
  /// It will cross a logical bitstream boundary, but only if it can't get any
  /// packets out of the tail of the link to which it seeks.
  /// \param _of          The \c OggOpusFile in which to seek.
  /// \param _byte_offset The byte position to seek to.
  /// This must be between 0 and #op_raw_total(\a _of,\c -1)
  /// (inclusive).
  /// \return 0 on success, or a negative error code on failure.
  /// \retval #OP_EREAD    The underlying seek operation failed.
  /// \retval #OP_EINVAL   The stream was only partially open, or the target was
  /// outside the valid range for the stream.
  /// \retval #OP_ENOSEEK  This stream is not seekable.
  /// \retval #OP_EBADLINK Failed to initialize a decoder for a stream for an
  /// unknown reason.
  int op_raw_seek(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<opus_int64> _byte_offset,
  ) {
    return _op_raw_seek(
      _of,
      _byte_offset,
    );
  }

  late final _op_raw_seekPtr =
      _lookup<ffi.NativeFunction<NativeOp_raw_seek>>('op_raw_seek');
  late final _op_raw_seek =
      _op_raw_seekPtr.asFunction<DartOp_raw_seek>(isLeaf: true);

  /// Seek to the specified PCM offset, such that decoding will begin at exactly
  /// the requested position.
  /// \param _of         The \c OggOpusFile in which to seek.
  /// \param _pcm_offset The PCM offset to seek to.
  /// This is in samples at 48 kHz relative to the start of the
  /// stream.
  /// \return 0 on success, or a negative value on error.
  /// \retval #OP_EREAD    An underlying read or seek operation failed.
  /// \retval #OP_EINVAL   The stream was only partially open, or the target was
  /// outside the valid range for the stream.
  /// \retval #OP_ENOSEEK  This stream is not seekable.
  /// \retval #OP_EBADLINK We failed to find data we had seen before, or the
  /// bitstream structure was sufficiently malformed that
  /// seeking to the target destination was impossible.
  int op_pcm_seek(
    ffi.Pointer<OggOpusFile> _of,
    int _pcm_offset,
  ) {
    return _op_pcm_seek(
      _of,
      _pcm_offset,
    );
  }

  late final _op_pcm_seekPtr =
      _lookup<ffi.NativeFunction<NativeOp_pcm_seek>>('op_pcm_seek');
  late final _op_pcm_seek =
      _op_pcm_seekPtr.asFunction<DartOp_pcm_seek>(isLeaf: true);

  /// Sets the packet decode callback function.
  /// If set, this is called once for each packet that needs to be decoded.
  /// This can be used by advanced applications to do additional processing on the
  /// compressed or uncompressed data.
  /// For example, an application might save the final entropy coder state for
  /// debugging and testing purposes, or it might apply additional filters
  /// before the downmixing, dithering, or soft-clipping performed by
  /// <tt>libopusfile</tt>, so long as these filters do not introduce any
  /// latency.
  ///
  /// A call to this function is no guarantee that the audio will eventually be
  /// delivered to the application.
  /// <tt>libopusfile</tt> may discard some or all of the decoded audio data
  /// (i.e., at the beginning or end of a link, or after a seek), however the
  /// callback is still required to provide all of it.
  /// \param _of        The \c OggOpusFile on which to set the decode callback.
  /// \param _decode_cb The callback function to call.
  /// This may be <code>NULL</code> to disable calling the
  /// callback.
  /// \param _ctx       The application-provided context pointer to pass to the
  /// callback on each call.
  void op_set_decode_callback(
    ffi.Pointer<OggOpusFile> _of,
    op_decode_cb_func _decode_cb,
    ffi.Pointer<ffi.Void> _ctx,
  ) {
    return _op_set_decode_callback(
      _of,
      _decode_cb,
      _ctx,
    );
  }

  late final _op_set_decode_callbackPtr =
      _lookup<ffi.NativeFunction<NativeOp_set_decode_callback>>(
          'op_set_decode_callback');
  late final _op_set_decode_callback = _op_set_decode_callbackPtr
      .asFunction<DartOp_set_decode_callback>(isLeaf: true);

  /// Sets the gain to be used for decoded output.
  /// By default, the gain in the header is applied with no additional offset.
  /// The total gain (including header gain and/or track gain, if applicable, and
  /// this offset), will be clamped to [-32768,32767]/256 dB.
  /// This is more than enough to saturate or underflow 16-bit PCM.
  /// \note The new gain will not be applied to any already buffered, decoded
  /// output.
  /// This means you cannot change it sample-by-sample, as at best it will be
  /// updated packet-by-packet.
  /// It is meant for setting a target volume level, rather than applying smooth
  /// fades, etc.
  /// \param _of             The \c OggOpusFile on which to set the gain offset.
  /// \param _gain_type      One of #OP_HEADER_GAIN, #OP_ALBUM_GAIN,
  /// #OP_TRACK_GAIN, or #OP_ABSOLUTE_GAIN.
  /// \param _gain_offset_q8 The gain offset to apply, in 1/256ths of a dB.
  /// \return 0 on success or a negative value on error.
  /// \retval #OP_EINVAL The \a _gain_type was unrecognized.
  int op_set_gain_offset(
    ffi.Pointer<OggOpusFile> _of,
    int _gain_type,
    int _gain_offset_q8,
  ) {
    return _op_set_gain_offset(
      _of,
      _gain_type,
      _gain_offset_q8,
    );
  }

  late final _op_set_gain_offsetPtr =
      _lookup<ffi.NativeFunction<NativeOp_set_gain_offset>>(
          'op_set_gain_offset');
  late final _op_set_gain_offset =
      _op_set_gain_offsetPtr.asFunction<DartOp_set_gain_offset>(isLeaf: true);

  /// Sets whether or not dithering is enabled for 16-bit decoding.
  /// By default, when <tt>libopusfile</tt> is compiled to use floating-point
  /// internally, calling op_read() or op_read_stereo() will first decode to
  /// float, and then convert to fixed-point using noise-shaping dithering.
  /// This flag can be used to disable that dithering.
  /// When the application uses op_read_float() or op_read_float_stereo(), or when
  /// the library has been compiled to decode directly to fixed point, this flag
  /// has no effect.
  /// \param _of      The \c OggOpusFile on which to enable or disable dithering.
  /// \param _enabled A non-zero value to enable dithering, or 0 to disable it.
  void op_set_dither_enabled(
    ffi.Pointer<OggOpusFile> _of,
    int _enabled,
  ) {
    return _op_set_dither_enabled(
      _of,
      _enabled,
    );
  }

  late final _op_set_dither_enabledPtr =
      _lookup<ffi.NativeFunction<NativeOp_set_dither_enabled>>(
          'op_set_dither_enabled');
  late final _op_set_dither_enabled = _op_set_dither_enabledPtr
      .asFunction<DartOp_set_dither_enabled>(isLeaf: true);

  /// Reads more samples from the stream.
  /// \note Although \a _buf_size must indicate the total number of values that
  /// can be stored in \a _pcm, the return value is the number of samples
  /// <em>per channel</em>.
  /// This is done because
  /// <ol>
  /// <li>The channel count cannot be known a priori (reading more samples might
  /// advance us into the next link, with a different channel count), so
  /// \a _buf_size cannot also be in units of samples per channel,</li>
  /// <li>Returning the samples per channel matches the <code>libopus</code> API
  /// as closely as we're able,</li>
  /// <li>Returning the total number of values instead of samples per channel
  /// would mean the caller would need a division to compute the samples per
  /// channel, and might worry about the possibility of getting back samples
  /// for some channels and not others, and</li>
  /// <li>This approach is relatively fool-proof: if an application passes too
  /// small a value to \a _buf_size, they will simply get fewer samples back,
  /// and if they assume the return value is the total number of values, then
  /// they will simply read too few (rather than reading too many and going
  /// off the end of the buffer).</li>
  /// </ol>
  /// \param      _of       The \c OggOpusFile from which to read.
  /// \param[out] _pcm      A buffer in which to store the output PCM samples, as
  /// signed native-endian 16-bit values at 48&nbsp;kHz
  /// with a nominal range of <code>[-32768,32767)</code>.
  /// Multiple channels are interleaved using the
  /// <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-810004.3.9">Vorbis
  /// channel ordering</a>.
  /// This must have room for at least \a _buf_size values.
  /// \param      _buf_size The number of values that can be stored in \a _pcm.
  /// It is recommended that this be large enough for at
  /// least 120 ms of data at 48 kHz per channel (5760
  /// values per channel).
  /// Smaller buffers will simply return less data, possibly
  /// consuming more memory to buffer the data internally.
  /// <tt>libopusfile</tt> may return less data than
  /// requested.
  /// If so, there is no guarantee that the remaining data
  /// in \a _pcm will be unmodified.
  /// \param[out] _li       The index of the link this data was decoded from.
  /// You may pass <code>NULL</code> if you do not need this
  /// information.
  /// If this function fails (returning a negative value),
  /// this parameter is left unset.
  /// \return The number of samples read per channel on success, or a negative
  /// value on failure.
  /// The channel count can be retrieved on success by calling
  /// <code>op_head(_of,*_li)</code>.
  /// The number of samples returned may be 0 if the buffer was too small
  /// to store even a single sample for all channels, or if end-of-file
  /// was reached.
  /// The list of possible failure codes follows.
  /// Most of them can only be returned by unseekable, chained streams
  /// that encounter a new link.
  /// \retval #OP_HOLE          There was a hole in the data, and some samples
  /// may have been skipped.
  /// Call this function again to continue decoding
  /// past the hole.
  /// \retval #OP_EREAD         An underlying read operation failed.
  /// This may signal a truncation attack from an
  /// <https:> source.
  /// \retval #OP_EFAULT        An internal memory allocation failed.
  /// \retval #OP_EIMPL         An unseekable stream encountered a new link that
  /// used a feature that is not implemented, such as
  /// an unsupported channel family.
  /// \retval #OP_EINVAL        The stream was only partially open.
  /// \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
  /// did not have any logical Opus streams in it.
  /// \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
  /// required header packet that was not properly
  /// formatted, contained illegal values, or was
  /// missing altogether.
  /// \retval #OP_EVERSION      An unseekable stream encountered a new link with
  /// an ID header that contained an unrecognized
  /// version number.
  /// \retval #OP_EBADPACKET    Failed to properly decode the next packet.
  /// \retval #OP_EBADLINK      We failed to find data we had seen before.
  /// \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
  /// a starting timestamp that failed basic validity
  /// checks.
  int op_read(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Int> _pcm,
    int _buf_size,
    ffi.Pointer<ffi.Int> _li,
  ) {
    return _op_read(
      _of,
      _pcm,
      _buf_size,
      _li,
    );
  }

  late final _op_readPtr =
      _lookup<ffi.NativeFunction<NativeOp_read>>('op_read');
  late final _op_read = _op_readPtr.asFunction<DartOp_read>(isLeaf: true);

  /// Reads more samples from the stream.
  /// \note Although \a _buf_size must indicate the total number of values that
  /// can be stored in \a _pcm, the return value is the number of samples
  /// <em>per channel</em>.
  /// <ol>
  /// <li>The channel count cannot be known a priori (reading more samples might
  /// advance us into the next link, with a different channel count), so
  /// \a _buf_size cannot also be in units of samples per channel,</li>
  /// <li>Returning the samples per channel matches the <code>libopus</code> API
  /// as closely as we're able,</li>
  /// <li>Returning the total number of values instead of samples per channel
  /// would mean the caller would need a division to compute the samples per
  /// channel, and might worry about the possibility of getting back samples
  /// for some channels and not others, and</li>
  /// <li>This approach is relatively fool-proof: if an application passes too
  /// small a value to \a _buf_size, they will simply get fewer samples back,
  /// and if they assume the return value is the total number of values, then
  /// they will simply read too few (rather than reading too many and going
  /// off the end of the buffer).</li>
  /// </ol>
  /// \param      _of       The \c OggOpusFile from which to read.
  /// \param[out] _pcm      A buffer in which to store the output PCM samples as
  /// signed floats at 48&nbsp;kHz with a nominal range of
  /// <code>[-1.0,1.0]</code>.
  /// Multiple channels are interleaved using the
  /// <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-810004.3.9">Vorbis
  /// channel ordering</a>.
  /// This must have room for at least \a _buf_size floats.
  /// \param      _buf_size The number of floats that can be stored in \a _pcm.
  /// It is recommended that this be large enough for at
  /// least 120 ms of data at 48 kHz per channel (5760
  /// samples per channel).
  /// Smaller buffers will simply return less data, possibly
  /// consuming more memory to buffer the data internally.
  /// If less than \a _buf_size values are returned,
  /// <tt>libopusfile</tt> makes no guarantee that the
  /// remaining data in \a _pcm will be unmodified.
  /// \param[out] _li       The index of the link this data was decoded from.
  /// You may pass <code>NULL</code> if you do not need this
  /// information.
  /// If this function fails (returning a negative value),
  /// this parameter is left unset.
  /// \return The number of samples read per channel on success, or a negative
  /// value on failure.
  /// The channel count can be retrieved on success by calling
  /// <code>op_head(_of,*_li)</code>.
  /// The number of samples returned may be 0 if the buffer was too small
  /// to store even a single sample for all channels, or if end-of-file
  /// was reached.
  /// The list of possible failure codes follows.
  /// Most of them can only be returned by unseekable, chained streams
  /// that encounter a new link.
  /// \retval #OP_HOLE          There was a hole in the data, and some samples
  /// may have been skipped.
  /// Call this function again to continue decoding
  /// past the hole.
  /// \retval #OP_EREAD         An underlying read operation failed.
  /// This may signal a truncation attack from an
  /// <https:> source.
  /// \retval #OP_EFAULT        An internal memory allocation failed.
  /// \retval #OP_EIMPL         An unseekable stream encountered a new link that
  /// used a feature that is not implemented, such as
  /// an unsupported channel family.
  /// \retval #OP_EINVAL        The stream was only partially open.
  /// \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
  /// did not have any logical Opus streams in it.
  /// \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
  /// required header packet that was not properly
  /// formatted, contained illegal values, or was
  /// missing altogether.
  /// \retval #OP_EVERSION      An unseekable stream encountered a new link with
  /// an ID header that contained an unrecognized
  /// version number.
  /// \retval #OP_EBADPACKET    Failed to properly decode the next packet.
  /// \retval #OP_EBADLINK      We failed to find data we had seen before.
  /// \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
  /// a starting timestamp that failed basic validity
  /// checks.
  int op_read_float(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Float> _pcm,
    int _buf_size,
    ffi.Pointer<ffi.Int> _li,
  ) {
    return _op_read_float(
      _of,
      _pcm,
      _buf_size,
      _li,
    );
  }

  late final _op_read_floatPtr =
      _lookup<ffi.NativeFunction<NativeOp_read_float>>('op_read_float');
  late final _op_read_float =
      _op_read_floatPtr.asFunction<DartOp_read_float>(isLeaf: true);

  /// Reads more samples from the stream and downmixes to stereo, if necessary.
  /// This function is intended for simple players that want a uniform output
  /// format, even if the channel count changes between links in a chained
  /// stream.
  /// \note \a _buf_size indicates the total number of values that can be stored
  /// in \a _pcm, while the return value is the number of samples <em>per
  /// channel</em>, even though the channel count is known, for consistency with
  /// op_read().
  /// \param      _of       The \c OggOpusFile from which to read.
  /// \param[out] _pcm      A buffer in which to store the output PCM samples, as
  /// signed native-endian 16-bit values at 48&nbsp;kHz
  /// with a nominal range of <code>[-32768,32767)</code>.
  /// The left and right channels are interleaved in the
  /// buffer.
  /// This must have room for at least \a _buf_size values.
  /// \param      _buf_size The number of values that can be stored in \a _pcm.
  /// It is recommended that this be large enough for at
  /// least 120 ms of data at 48 kHz per channel (11520
  /// values total).
  /// Smaller buffers will simply return less data, possibly
  /// consuming more memory to buffer the data internally.
  /// If less than \a _buf_size values are returned,
  /// <tt>libopusfile</tt> makes no guarantee that the
  /// remaining data in \a _pcm will be unmodified.
  /// \return The number of samples read per channel on success, or a negative
  /// value on failure.
  /// The number of samples returned may be 0 if the buffer was too small
  /// to store even a single sample for both channels, or if end-of-file
  /// was reached.
  /// The list of possible failure codes follows.
  /// Most of them can only be returned by unseekable, chained streams
  /// that encounter a new link.
  /// \retval #OP_HOLE          There was a hole in the data, and some samples
  /// may have been skipped.
  /// Call this function again to continue decoding
  /// past the hole.
  /// \retval #OP_EREAD         An underlying read operation failed.
  /// This may signal a truncation attack from an
  /// <https:> source.
  /// \retval #OP_EFAULT        An internal memory allocation failed.
  /// \retval #OP_EIMPL         An unseekable stream encountered a new link that
  /// used a feature that is not implemented, such as
  /// an unsupported channel family.
  /// \retval #OP_EINVAL        The stream was only partially open.
  /// \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
  /// did not have any logical Opus streams in it.
  /// \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
  /// required header packet that was not properly
  /// formatted, contained illegal values, or was
  /// missing altogether.
  /// \retval #OP_EVERSION      An unseekable stream encountered a new link with
  /// an ID header that contained an unrecognized
  /// version number.
  /// \retval #OP_EBADPACKET    Failed to properly decode the next packet.
  /// \retval #OP_EBADLINK      We failed to find data we had seen before.
  /// \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
  /// a starting timestamp that failed basic validity
  /// checks.
  int op_read_stereo(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Int> _pcm,
    int _buf_size,
  ) {
    return _op_read_stereo(
      _of,
      _pcm,
      _buf_size,
    );
  }

  late final _op_read_stereoPtr =
      _lookup<ffi.NativeFunction<NativeOp_read_stereo>>('op_read_stereo');
  late final _op_read_stereo =
      _op_read_stereoPtr.asFunction<DartOp_read_stereo>(isLeaf: true);

  /// Reads more samples from the stream and downmixes to stereo, if necessary.
  /// This function is intended for simple players that want a uniform output
  /// format, even if the channel count changes between links in a chained
  /// stream.
  /// \note \a _buf_size indicates the total number of values that can be stored
  /// in \a _pcm, while the return value is the number of samples <em>per
  /// channel</em>, even though the channel count is known, for consistency with
  /// op_read_float().
  /// \param      _of       The \c OggOpusFile from which to read.
  /// \param[out] _pcm      A buffer in which to store the output PCM samples, as
  /// signed floats at 48&nbsp;kHz with a nominal range of
  /// <code>[-1.0,1.0]</code>.
  /// The left and right channels are interleaved in the
  /// buffer.
  /// This must have room for at least \a _buf_size values.
  /// \param      _buf_size The number of values that can be stored in \a _pcm.
  /// It is recommended that this be large enough for at
  /// least 120 ms of data at 48 kHz per channel (11520
  /// values total).
  /// Smaller buffers will simply return less data, possibly
  /// consuming more memory to buffer the data internally.
  /// If less than \a _buf_size values are returned,
  /// <tt>libopusfile</tt> makes no guarantee that the
  /// remaining data in \a _pcm will be unmodified.
  /// \return The number of samples read per channel on success, or a negative
  /// value on failure.
  /// The number of samples returned may be 0 if the buffer was too small
  /// to store even a single sample for both channels, or if end-of-file
  /// was reached.
  /// The list of possible failure codes follows.
  /// Most of them can only be returned by unseekable, chained streams
  /// that encounter a new link.
  /// \retval #OP_HOLE          There was a hole in the data, and some samples
  /// may have been skipped.
  /// Call this function again to continue decoding
  /// past the hole.
  /// \retval #OP_EREAD         An underlying read operation failed.
  /// This may signal a truncation attack from an
  /// <https:> source.
  /// \retval #OP_EFAULT        An internal memory allocation failed.
  /// \retval #OP_EIMPL         An unseekable stream encountered a new link that
  /// used a feature that is not implemented, such as
  /// an unsupported channel family.
  /// \retval #OP_EINVAL        The stream was only partially open.
  /// \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
  /// that did not have any logical Opus streams in it.
  /// \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
  /// required header packet that was not properly
  /// formatted, contained illegal values, or was
  /// missing altogether.
  /// \retval #OP_EVERSION      An unseekable stream encountered a new link with
  /// an ID header that contained an unrecognized
  /// version number.
  /// \retval #OP_EBADPACKET    Failed to properly decode the next packet.
  /// \retval #OP_EBADLINK      We failed to find data we had seen before.
  /// \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
  /// a starting timestamp that failed basic validity
  /// checks.
  int op_read_float_stereo(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Float> _pcm,
    int _buf_size,
  ) {
    return _op_read_float_stereo(
      _of,
      _pcm,
      _buf_size,
    );
  }

  late final _op_read_float_stereoPtr =
      _lookup<ffi.NativeFunction<NativeOp_read_float_stereo>>(
          'op_read_float_stereo');
  late final _op_read_float_stereo = _op_read_float_stereoPtr
      .asFunction<DartOp_read_float_stereo>(isLeaf: true);
}

typedef va_list = ffi.Pointer<ffi.Char>;
typedef Native__va_start = ffi.Void Function(ffi.Pointer<va_list> arg0);
typedef Dart__va_start = void Function(ffi.Pointer<va_list> arg0);
typedef Native__security_init_cookie = ffi.Void Function();
typedef Dart__security_init_cookie = void Function();
typedef Native__security_check_cookie = ffi.Void Function(
    ffi.UintPtr _StackCookie);
typedef Dart__security_check_cookie = void Function(int _StackCookie);
typedef Native__report_gsfailure = ffi.Void Function(ffi.UintPtr _StackCookie);
typedef Dart__report_gsfailure = void Function(int _StackCookie);
typedef Native_invalid_parameter_noinfo = ffi.Void Function();
typedef Dart_invalid_parameter_noinfo = void Function();
typedef Native_invalid_parameter_noinfo_noreturn = ffi.Void Function();
typedef Dart_invalid_parameter_noinfo_noreturn = void Function();
typedef Native_invoke_watson = ffi.Void Function(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.UnsignedInt _LineNo,
    ffi.UintPtr _Reserved);
typedef Dart_invoke_watson = void Function(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved);

final class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

final class _iobuf extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

typedef FILE = _iobuf;
typedef Native__acrt_iob_func = ffi.Pointer<FILE> Function(ffi.UnsignedInt _Ix);
typedef Dart__acrt_iob_func = ffi.Pointer<FILE> Function(int _Ix);
typedef wint_t = ffi.UnsignedShort;
typedef Dartwint_t = int;
typedef NativeFgetwc = wint_t Function(ffi.Pointer<FILE> _Stream);
typedef DartFgetwc = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fgetwchar = wint_t Function();
typedef Dart_fgetwchar = int Function();
typedef NativeFputwc = wint_t Function(
    ffi.WChar _Character, ffi.Pointer<FILE> _Stream);
typedef DartFputwc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_fputwchar = wint_t Function(ffi.WChar _Character);
typedef Dart_fputwchar = int Function(int _Character);
typedef NativeGetwc = wint_t Function(ffi.Pointer<FILE> _Stream);
typedef DartGetwc = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeGetwchar = wint_t Function();
typedef DartGetwchar = int Function();
typedef NativeFgetws = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Int _BufferCount,
    ffi.Pointer<FILE> _Stream);
typedef DartFgetws = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<FILE> _Stream);
typedef NativeFputws = ffi.Int Function(
    ffi.Pointer<ffi.WChar> _Buffer, ffi.Pointer<FILE> _Stream);
typedef DartFputws = int Function(
    ffi.Pointer<ffi.WChar> _Buffer, ffi.Pointer<FILE> _Stream);
typedef Native_getws_s = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer, ffi.Size _BufferCount);
typedef Dart_getws_s = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer, int _BufferCount);
typedef NativePutwc = wint_t Function(
    ffi.WChar _Character, ffi.Pointer<FILE> _Stream);
typedef DartPutwc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef NativePutwchar = wint_t Function(ffi.WChar _Character);
typedef DartPutwchar = int Function(int _Character);
typedef Native_putws = ffi.Int Function(ffi.Pointer<ffi.WChar> _Buffer);
typedef Dart_putws = int Function(ffi.Pointer<ffi.WChar> _Buffer);
typedef NativeUngetwc = wint_t Function(
    wint_t _Character, ffi.Pointer<FILE> _Stream);
typedef DartUngetwc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_wfdopen = ffi.Pointer<FILE> Function(
    ffi.Int _FileHandle, ffi.Pointer<ffi.WChar> _Mode);
typedef Dart_wfdopen = ffi.Pointer<FILE> Function(
    int _FileHandle, ffi.Pointer<ffi.WChar> _Mode);
typedef Native_wfopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName, ffi.Pointer<ffi.WChar> _Mode);
typedef Dart_wfopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName, ffi.Pointer<ffi.WChar> _Mode);
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;
typedef Native_wfopen_s = errno_t Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode);
typedef Dart_wfopen_s = int Function(ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName, ffi.Pointer<ffi.WChar> _Mode);
typedef Native_wfreopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef Dart_wfreopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef Native_wfreopen_s = errno_t Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef Dart_wfreopen_s = int Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef Native_wfsopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Int _ShFlag);
typedef Dart_wfsopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    int _ShFlag);
typedef Native_wperror = ffi.Void Function(
    ffi.Pointer<ffi.WChar> _ErrorMessage);
typedef Dart_wperror = void Function(ffi.Pointer<ffi.WChar> _ErrorMessage);
typedef Native_wpopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _Command, ffi.Pointer<ffi.WChar> _Mode);
typedef Dart_wpopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.WChar> _Command, ffi.Pointer<ffi.WChar> _Mode);
typedef Native_wremove = ffi.Int Function(ffi.Pointer<ffi.WChar> _FileName);
typedef Dart_wremove = int Function(ffi.Pointer<ffi.WChar> _FileName);
typedef Native_wtempnam = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Directory, ffi.Pointer<ffi.WChar> _FilePrefix);
typedef Dart_wtempnam = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Directory, ffi.Pointer<ffi.WChar> _FilePrefix);
typedef Native_wtmpnam_s = errno_t Function(
    ffi.Pointer<ffi.WChar> _Buffer, ffi.Size _BufferCount);
typedef Dart_wtmpnam_s = int Function(
    ffi.Pointer<ffi.WChar> _Buffer, int _BufferCount);
typedef Native_wtmpnam = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer);
typedef Dart_wtmpnam = ffi.Pointer<ffi.WChar> Function(
    ffi.Pointer<ffi.WChar> _Buffer);
typedef Native_fgetwc_nolock = wint_t Function(ffi.Pointer<FILE> _Stream);
typedef Dart_fgetwc_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fputwc_nolock = wint_t Function(
    ffi.WChar _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_fputwc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_getwc_nolock = wint_t Function(ffi.Pointer<FILE> _Stream);
typedef Dart_getwc_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_putwc_nolock = wint_t Function(
    ffi.WChar _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_putwc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_ungetwc_nolock = wint_t Function(
    wint_t _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_ungetwc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;
typedef Native__stdio_common_vfwprintf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfwprintf = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vfwprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfwprintf_s = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vfwprintf_p = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfwprintf_p = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vfwscanf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfwscanf = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vswprintf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vswprintf = int Function(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vswprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vswprintf_s = int Function(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vsnwprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Size _BufferCount,
    ffi.Size _MaxCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsnwprintf_s = int Function(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vswprintf_p = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vswprintf_p = int Function(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vswscanf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vswscanf = int Function(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native_get_stream_buffer_pointers = errno_t Function(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Base,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Pointer,
    ffi.Pointer<ffi.Pointer<ffi.Int>> _Count);
typedef Dart_get_stream_buffer_pointers = int Function(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Base,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Pointer,
    ffi.Pointer<ffi.Pointer<ffi.Int>> _Count);
typedef NativeClearerr_s = errno_t Function(ffi.Pointer<FILE> _Stream);
typedef DartClearerr_s = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFopen_s = errno_t Function(ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName, ffi.Pointer<ffi.Char> _Mode);
typedef DartFopen_s = int Function(ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName, ffi.Pointer<ffi.Char> _Mode);
typedef NativeFread_s = ffi.Size Function(
    ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _BufferSize,
    ffi.Size _ElementSize,
    ffi.Size _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef DartFread_s = int Function(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef NativeFreopen_s = errno_t Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef DartFreopen_s = int Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _OldStream);
typedef rsize_t = ffi.Size;
typedef Dartrsize_t = int;
typedef NativeGets_s = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer, rsize_t _Size);
typedef DartGets_s = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer, int _Size);
typedef NativeTmpfile_s = errno_t Function(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream);
typedef DartTmpfile_s = int Function(ffi.Pointer<ffi.Pointer<FILE>> _Stream);
typedef NativeTmpnam_s = errno_t Function(
    ffi.Pointer<ffi.Char> _Buffer, rsize_t _Size);
typedef DartTmpnam_s = int Function(ffi.Pointer<ffi.Char> _Buffer, int _Size);
typedef NativeClearerr = ffi.Void Function(ffi.Pointer<FILE> _Stream);
typedef DartClearerr = void Function(ffi.Pointer<FILE> _Stream);
typedef NativeFclose = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFclose = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fcloseall = ffi.Int Function();
typedef Dart_fcloseall = int Function();
typedef Native_fdopen = ffi.Pointer<FILE> Function(
    ffi.Int _FileHandle, ffi.Pointer<ffi.Char> _Mode);
typedef Dart_fdopen = ffi.Pointer<FILE> Function(
    int _FileHandle, ffi.Pointer<ffi.Char> _Mode);
typedef NativeFeof = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFeof = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFerror = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFerror = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFflush = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFflush = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFgetc = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFgetc = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fgetchar = ffi.Int Function();
typedef Dart_fgetchar = int Function();
typedef fpos_t = ffi.LongLong;
typedef Dartfpos_t = int;
typedef NativeFgetpos = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<fpos_t> _Position);
typedef DartFgetpos = int Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<fpos_t> _Position);
typedef NativeFgets = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Int _MaxCount,
    ffi.Pointer<FILE> _Stream);
typedef DartFgets = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer, int _MaxCount, ffi.Pointer<FILE> _Stream);
typedef Native_fileno = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_fileno = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_flushall = ffi.Int Function();
typedef Dart_flushall = int Function();
typedef NativeFopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName, ffi.Pointer<ffi.Char> _Mode);
typedef DartFopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName, ffi.Pointer<ffi.Char> _Mode);
typedef NativeFputc = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef DartFputc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_fputchar = ffi.Int Function(ffi.Int _Character);
typedef Dart_fputchar = int Function(int _Character);
typedef NativeFputs = ffi.Int Function(
    ffi.Pointer<ffi.Char> _Buffer, ffi.Pointer<FILE> _Stream);
typedef DartFputs = int Function(
    ffi.Pointer<ffi.Char> _Buffer, ffi.Pointer<FILE> _Stream);
typedef NativeFread = ffi.UnsignedLongLong Function(
    ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _ElementSize,
    ffi.Size _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef DartFread = int Function(ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize, int _ElementCount, ffi.Pointer<FILE> _Stream);
typedef NativeFreopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _Stream);
typedef DartFreopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _Stream);
typedef Native_fsopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Int _ShFlag);
typedef Dart_fsopen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _FileName, ffi.Pointer<ffi.Char> _Mode, int _ShFlag);
typedef NativeFsetpos = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<fpos_t> _Position);
typedef DartFsetpos = int Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<fpos_t> _Position);
typedef NativeFseek = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.Long _Offset, ffi.Int _Origin);
typedef DartFseek = int Function(
    ffi.Pointer<FILE> _Stream, int _Offset, int _Origin);
typedef Native_fseeki64 = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.LongLong _Offset, ffi.Int _Origin);
typedef Dart_fseeki64 = int Function(
    ffi.Pointer<FILE> _Stream, int _Offset, int _Origin);
typedef NativeFtell = ffi.Long Function(ffi.Pointer<FILE> _Stream);
typedef DartFtell = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_ftelli64 = ffi.LongLong Function(ffi.Pointer<FILE> _Stream);
typedef Dart_ftelli64 = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFwrite = ffi.UnsignedLongLong Function(
    ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _ElementSize,
    ffi.Size _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef DartFwrite = int Function(ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize, int _ElementCount, ffi.Pointer<FILE> _Stream);
typedef NativeGetc = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartGetc = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeGetchar = ffi.Int Function();
typedef DartGetchar = int Function();
typedef Native_getmaxstdio = ffi.Int Function();
typedef Dart_getmaxstdio = int Function();
typedef Native_getw = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_getw = int Function(ffi.Pointer<FILE> _Stream);
typedef NativePerror = ffi.Void Function(ffi.Pointer<ffi.Char> _ErrorMessage);
typedef DartPerror = void Function(ffi.Pointer<ffi.Char> _ErrorMessage);
typedef Native_pclose = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_pclose = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_popen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _Command, ffi.Pointer<ffi.Char> _Mode);
typedef Dart_popen = ffi.Pointer<FILE> Function(
    ffi.Pointer<ffi.Char> _Command, ffi.Pointer<ffi.Char> _Mode);
typedef NativePutc = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef DartPutc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef NativePutchar = ffi.Int Function(ffi.Int _Character);
typedef DartPutchar = int Function(int _Character);
typedef NativePuts = ffi.Int Function(ffi.Pointer<ffi.Char> _Buffer);
typedef DartPuts = int Function(ffi.Pointer<ffi.Char> _Buffer);
typedef Native_putw = ffi.Int Function(
    ffi.Int _Word, ffi.Pointer<FILE> _Stream);
typedef Dart_putw = int Function(int _Word, ffi.Pointer<FILE> _Stream);
typedef NativeRemove = ffi.Int Function(ffi.Pointer<ffi.Char> _FileName);
typedef DartRemove = int Function(ffi.Pointer<ffi.Char> _FileName);
typedef NativeRename = ffi.Int Function(
    ffi.Pointer<ffi.Char> _OldFileName, ffi.Pointer<ffi.Char> _NewFileName);
typedef DartRename = int Function(
    ffi.Pointer<ffi.Char> _OldFileName, ffi.Pointer<ffi.Char> _NewFileName);
typedef Native_unlink = ffi.Int Function(ffi.Pointer<ffi.Char> _FileName);
typedef Dart_unlink = int Function(ffi.Pointer<ffi.Char> _FileName);
typedef NativeUnlink = ffi.Int Function(ffi.Pointer<ffi.Char> _FileName);
typedef DartUnlink = int Function(ffi.Pointer<ffi.Char> _FileName);
typedef NativeRewind = ffi.Void Function(ffi.Pointer<FILE> _Stream);
typedef DartRewind = void Function(ffi.Pointer<FILE> _Stream);
typedef Native_rmtmp = ffi.Int Function();
typedef Dart_rmtmp = int Function();
typedef NativeSetbuf = ffi.Void Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<ffi.Char> _Buffer);
typedef DartSetbuf = void Function(
    ffi.Pointer<FILE> _Stream, ffi.Pointer<ffi.Char> _Buffer);
typedef Native_setmaxstdio = ffi.Int Function(ffi.Int _Maximum);
typedef Dart_setmaxstdio = int Function(int _Maximum);
typedef NativeSetvbuf = ffi.Int Function(ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer, ffi.Int _Mode, ffi.Size _Size);
typedef DartSetvbuf = int Function(ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer, int _Mode, int _Size);
typedef Native_tempnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _DirectoryName, ffi.Pointer<ffi.Char> _FilePrefix);
typedef Dart_tempnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _DirectoryName, ffi.Pointer<ffi.Char> _FilePrefix);
typedef NativeTmpfile = ffi.Pointer<FILE> Function();
typedef DartTmpfile = ffi.Pointer<FILE> Function();
typedef NativeTmpnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer);
typedef DartTmpnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Buffer);
typedef NativeUngetc = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef DartUngetc = int Function(int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_lock_file = ffi.Void Function(ffi.Pointer<FILE> _Stream);
typedef Dart_lock_file = void Function(ffi.Pointer<FILE> _Stream);
typedef Native_unlock_file = ffi.Void Function(ffi.Pointer<FILE> _Stream);
typedef Dart_unlock_file = void Function(ffi.Pointer<FILE> _Stream);
typedef Native_fclose_nolock = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_fclose_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fflush_nolock = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_fflush_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fgetc_nolock = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_fgetc_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fputc_nolock = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_fputc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_fread_nolock = ffi.Size Function(ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _ElementSize, ffi.Size _ElementCount, ffi.Pointer<FILE> _Stream);
typedef Dart_fread_nolock = int Function(ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize, int _ElementCount, ffi.Pointer<FILE> _Stream);
typedef Native_fread_nolock_s = ffi.Size Function(
    ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _BufferSize,
    ffi.Size _ElementSize,
    ffi.Size _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef Dart_fread_nolock_s = int Function(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream);
typedef Native_fseek_nolock = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.Long _Offset, ffi.Int _Origin);
typedef Dart_fseek_nolock = int Function(
    ffi.Pointer<FILE> _Stream, int _Offset, int _Origin);
typedef Native_fseeki64_nolock = ffi.Int Function(
    ffi.Pointer<FILE> _Stream, ffi.LongLong _Offset, ffi.Int _Origin);
typedef Dart_fseeki64_nolock = int Function(
    ffi.Pointer<FILE> _Stream, int _Offset, int _Origin);
typedef Native_ftell_nolock = ffi.Long Function(ffi.Pointer<FILE> _Stream);
typedef Dart_ftell_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_ftelli64_nolock = ffi.LongLong Function(
    ffi.Pointer<FILE> _Stream);
typedef Dart_ftelli64_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_fwrite_nolock = ffi.Size Function(ffi.Pointer<ffi.Void> _Buffer,
    ffi.Size _ElementSize, ffi.Size _ElementCount, ffi.Pointer<FILE> _Stream);
typedef Dart_fwrite_nolock = int Function(ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize, int _ElementCount, ffi.Pointer<FILE> _Stream);
typedef Native_getc_nolock = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef Dart_getc_nolock = int Function(ffi.Pointer<FILE> _Stream);
typedef Native_putc_nolock = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_putc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef Native_ungetc_nolock = ffi.Int Function(
    ffi.Int _Character, ffi.Pointer<FILE> _Stream);
typedef Dart_ungetc_nolock = int Function(
    int _Character, ffi.Pointer<FILE> _Stream);
typedef Native__p__commode = ffi.Pointer<ffi.Int> Function();
typedef Dart__p__commode = ffi.Pointer<ffi.Int> Function();
typedef Native__stdio_common_vfprintf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfprintf = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vfprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfprintf_s = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vfprintf_p = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vfprintf_p = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native_set_printf_count_output = ffi.Int Function(ffi.Int _Value);
typedef Dart_set_printf_count_output = int Function(int _Value);
typedef Native_get_printf_count_output = ffi.Int Function();
typedef Dart_get_printf_count_output = int Function();
typedef Native__stdio_common_vfscanf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _Arglist);
typedef Dart__stdio_common_vfscanf = int Function(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _Arglist);
typedef Native__stdio_common_vsprintf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsprintf = int Function(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vsprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsprintf_s = int Function(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vsnprintf_s = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Size _BufferCount,
    ffi.Size _MaxCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsnprintf_s = int Function(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vsprintf_p = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsprintf_p = int Function(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Native__stdio_common_vsscanf = ffi.Int Function(
    ffi.UnsignedLongLong _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Size _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef Dart__stdio_common_vsscanf = int Function(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList);
typedef NativeTempnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Directory, ffi.Pointer<ffi.Char> _FilePrefix);
typedef DartTempnam = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char> _Directory, ffi.Pointer<ffi.Char> _FilePrefix);
typedef NativeFcloseall = ffi.Int Function();
typedef DartFcloseall = int Function();
typedef NativeFdopen = ffi.Pointer<FILE> Function(
    ffi.Int _FileHandle, ffi.Pointer<ffi.Char> _Format);
typedef DartFdopen = ffi.Pointer<FILE> Function(
    int _FileHandle, ffi.Pointer<ffi.Char> _Format);
typedef NativeFgetchar = ffi.Int Function();
typedef DartFgetchar = int Function();
typedef NativeFileno = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartFileno = int Function(ffi.Pointer<FILE> _Stream);
typedef NativeFlushall = ffi.Int Function();
typedef DartFlushall = int Function();
typedef NativeFputchar = ffi.Int Function(ffi.Int _Ch);
typedef DartFputchar = int Function(int _Ch);
typedef NativeGetw = ffi.Int Function(ffi.Pointer<FILE> _Stream);
typedef DartGetw = int Function(ffi.Pointer<FILE> _Stream);
typedef NativePutw = ffi.Int Function(ffi.Int _Ch, ffi.Pointer<FILE> _Stream);
typedef DartPutw = int Function(int _Ch, ffi.Pointer<FILE> _Stream);
typedef NativeRmtmp = ffi.Int Function();
typedef DartRmtmp = int Function();

/// Ogg Opus bitstream information.
/// This contains the basic playback parameters for a stream, and corresponds to
/// the initial ID header packet of an Ogg Opus stream.
final class OpusHead extends ffi.Struct {
  /// The Ogg Opus format version, in the range 0...255.
  /// The top 4 bits represent a "major" version, and the bottom four bits
  /// represent backwards-compatible "minor" revisions.
  /// The current specification describes version 1.
  /// This library will recognize versions up through 15 as backwards compatible
  /// with the current specification.
  /// An earlier draft of the specification described a version 0, but the only
  /// difference between version 1 and version 0 is that version 0 did
  /// not specify the semantics for handling the version field.
  @ffi.Int()
  external int version;

  /// The number of channels, in the range 1...255.
  @ffi.Int()
  external int channel_count;

  /// The number of samples that should be discarded from the beginning of the
  /// stream.
  @ffi.UnsignedInt()
  external int pre_skip;

  /// The sampling rate of the original input.
  /// All Opus audio is coded at 48 kHz, and should also be decoded at 48 kHz
  /// for playback (unless the target hardware does not support this sampling
  /// rate).
  /// However, this field may be used to resample the audio back to the original
  /// sampling rate, for example, when saving the output to a file.
  @ffi.Int()
  external int input_sample_rate;

  /// The gain to apply to the decoded output, in dB, as a Q8 value in the range
  /// -32768...32767.
  /// The <tt>libopusfile</tt> API will automatically apply this gain to the
  /// decoded output before returning it, scaling it by
  /// <code>pow(10,output_gain/(20.0*256))</code>.
  /// You can adjust this behavior with op_set_gain_offset().
  @ffi.Int()
  external int output_gain;

  /// The channel mapping family, in the range 0...255.
  /// Channel mapping family 0 covers mono or stereo in a single stream.
  /// Channel mapping family 1 covers 1 to 8 channels in one or more streams,
  /// using the Vorbis speaker assignments.
  /// Channel mapping family 255 covers 1 to 255 channels in one or more
  /// streams, but without any defined speaker assignment.
  @ffi.Int()
  external int mapping_family;

  /// The number of Opus streams in each Ogg packet, in the range 1...255.
  @ffi.Int()
  external int stream_count;

  /// The number of coupled Opus streams in each Ogg packet, in the range
  /// 0...127.
  /// This must satisfy <code>0 <= coupled_count <= stream_count</code> and
  /// <code>coupled_count + stream_count <= 255</code>.
  /// The coupled streams appear first, before all uncoupled streams, in an Ogg
  /// Opus packet.
  @ffi.Int()
  external int coupled_count;

  /// The mapping from coded stream channels to output channels.
  /// Let <code>index=mapping[k]</code> be the value for channel <code>k</code>.
  /// If <code>index<2*coupled_count</code>, then it refers to the left channel
  /// from stream <code>(index/2)</code> if even, and the right channel from
  /// stream <code>(index/2)</code> if odd.
  /// Otherwise, it refers to the output of the uncoupled stream
  /// <code>(index-coupled_count)</code>.
  @ffi.Array.multi([255])
  external ffi.Array<ffi.UnsignedChar> mapping;
}

/// The metadata from an Ogg Opus stream.
///
/// This structure holds the in-stream metadata corresponding to the 'comment'
/// header packet of an Ogg Opus stream.
/// The comment header is meant to be used much like someone jotting a quick
/// note on the label of a CD.
/// It should be a short, to the point text note that can be more than a couple
/// words, but not more than a short paragraph.
///
/// The metadata is stored as a series of (tag, value) pairs, in length-encoded
/// string vectors, using the same format as Vorbis (without the final "framing
/// bit"), Theora, and Speex, except for the packet header.
/// The first occurrence of the '=' character delimits the tag and value.
/// A particular tag may occur more than once, and order is significant.
/// The character set encoding for the strings is always UTF-8, but the tag
/// names are limited to ASCII, and treated as case-insensitive.
/// See <a href="https://www.xiph.org/vorbis/doc/v-comment.html">the Vorbis
/// comment header specification</a> for details.
///
/// In filling in this structure, <tt>libopusfile</tt> will null-terminate the
/// #user_comments strings for safety.
/// However, the bitstream format itself treats them as 8-bit clean vectors,
/// possibly containing NUL characters, so the #comment_lengths array should be
/// treated as their authoritative length.
///
/// This structure is binary and source-compatible with a
/// <code>vorbis_comment</code>, and pointers to it may be freely cast to
/// <code>vorbis_comment</code> pointers, and vice versa.
/// It is provided as a separate type to avoid introducing a compile-time
/// dependency on the libvorbis headers.
final class OpusTags extends ffi.Struct {
  /// The array of comment string vectors.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> user_comments;

  /// An array of the corresponding length of each vector, in bytes.
  external ffi.Pointer<ffi.Int> comment_lengths;

  /// The total number of comment streams.
  @ffi.Int()
  external int comments;

  /// The null-terminated vendor string.
  /// This identifies the software used to encode the stream.
  external ffi.Pointer<ffi.Char> vendor;
}

/// The contents of a METADATA_BLOCK_PICTURE tag.
final class OpusPictureTag extends ffi.Struct {
  /// The picture type according to the ID3v2 APIC frame:
  /// <ol start="0">
  /// <li>Other</li>
  /// <li>32x32 pixels 'file icon' (PNG only)</li>
  /// <li>Other file icon</li>
  /// <li>Cover (front)</li>
  /// <li>Cover (back)</li>
  /// <li>Leaflet page</li>
  /// <li>Media (e.g. label side of CD)</li>
  /// <li>Lead artist/lead performer/soloist</li>
  /// <li>Artist/performer</li>
  /// <li>Conductor</li>
  /// <li>Band/Orchestra</li>
  /// <li>Composer</li>
  /// <li>Lyricist/text writer</li>
  /// <li>Recording Location</li>
  /// <li>During recording</li>
  /// <li>During performance</li>
  /// <li>Movie/video screen capture</li>
  /// <li>A bright colored fish</li>
  /// <li>Illustration</li>
  /// <li>Band/artist logotype</li>
  /// <li>Publisher/Studio logotype</li>
  /// </ol>
  /// Others are reserved and should not be used.
  /// There may only be one each of picture type 1 and 2 in a file.
  @ffi.Int()
  external int type;

  /// The MIME type of the picture, in printable ASCII characters 0x20-0x7E.
  /// The MIME type may also be <code>"-->"</code> to signify that the data part
  /// is a URL pointing to the picture instead of the picture data itself.
  /// In this case, a terminating NUL is appended to the URL string in #data,
  /// but #data_length is set to the length of the string excluding that
  /// terminating NUL.
  external ffi.Pointer<ffi.Char> mime_type;

  /// The description of the picture, in UTF-8.
  external ffi.Pointer<ffi.Char> description;

  /// The width of the picture in pixels.
  @ffi.Int()
  external int width;

  /// The height of the picture in pixels.
  @ffi.Int()
  external int height;

  /// The color depth of the picture in bits-per-pixel (<em>not</em>
  /// bits-per-channel).
  @ffi.Int()
  external int depth;

  /// For indexed-color pictures (e.g., GIF), the number of colors used, or 0
  /// for non-indexed pictures.
  @ffi.Int()
  external int colors;

  /// The length of the picture data in bytes.
  @ffi.Int()
  external int data_length;

  /// The binary picture data.
  external ffi.Pointer<ffi.UnsignedChar> data;

  /// The format of the picture data, if known.
  /// One of
  /// <ul>
  /// <li>#OP_PIC_FORMAT_UNKNOWN,</li>
  /// <li>#OP_PIC_FORMAT_URL,</li>
  /// <li>#OP_PIC_FORMAT_JPEG,</li>
  /// <li>#OP_PIC_FORMAT_PNG, or</li>
  /// <li>#OP_PIC_FORMAT_GIF.</li>
  /// </ul>
  @ffi.Int()
  external int format;
}

/// HTTP/Shoutcast/Icecast server information associated with a URL.
final class OpusServerInfo extends ffi.Struct {
  /// The name of the server (icy-name/ice-name).
  /// This is <code>NULL</code> if there was no <code>icy-name</code> or
  /// <code>ice-name</code> header.
  external ffi.Pointer<ffi.Char> name;

  /// A short description of the server (icy-description/ice-description).
  /// This is <code>NULL</code> if there was no <code>icy-description</code> or
  /// <code>ice-description</code> header.
  external ffi.Pointer<ffi.Char> description;

  /// The genre the server falls under (icy-genre/ice-genre).
  /// This is <code>NULL</code> if there was no <code>icy-genre</code> or
  /// <code>ice-genre</code> header.
  external ffi.Pointer<ffi.Char> genre;

  /// The homepage for the server (icy-url/ice-url).
  /// This is <code>NULL</code> if there was no <code>icy-url</code> or
  /// <code>ice-url</code> header.
  external ffi.Pointer<ffi.Char> url;

  /// The software used by the origin server (Server).
  /// This is <code>NULL</code> if there was no <code>Server</code> header.
  external ffi.Pointer<ffi.Char> server;

  /// The media type of the entity sent to the recepient (Content-Type).
  /// This is <code>NULL</code> if there was no <code>Content-Type</code>
  /// header.
  external ffi.Pointer<ffi.Char> content_type;

  /// The nominal stream bitrate in kbps (icy-br/ice-bitrate).
  /// This is <code>-1</code> if there was no <code>icy-br</code> or
  /// <code>ice-bitrate</code> header.
  @ffi.Int()
  external int bitrate_kbps;

  /// Flag indicating whether the server is public (<code>1</code>) or not
  /// (<code>0</code>) (icy-pub/ice-public).
  /// This is <code>-1</code> if there was no <code>icy-pub</code> or
  /// <code>ice-public</code> header.
  @ffi.Int()
  external int is_public;

  /// Flag indicating whether the server is using HTTPS instead of HTTP.
  /// This is <code>0</code> unless HTTPS is being used.
  /// This may not match the protocol used in the original URL if there were
  /// redirections.
  @ffi.Int()
  external int is_ssl;
}

/// The callbacks used to access non-<code>FILE</code> stream resources.
/// The function prototypes are basically the same as for the stdio functions
/// <code>fread()</code>, <code>fseek()</code>, <code>ftell()</code>, and
/// <code>fclose()</code>.
/// The differences are that the <code>FILE *</code> arguments have been
/// replaced with a <code>void *</code>, which is to be used as a pointer to
/// whatever internal data these functions might need, that #seek and #tell
/// take and return 64-bit offsets, and that #seek <em>must</em> return -1 if
/// the stream is unseekable.
final class OpusFileCallbacks extends ffi.Struct {
  /// Used to read data from the stream.
  /// This must not be <code>NULL</code>.
  external op_read_func read;

  /// Used to seek in the stream.
  /// This may be <code>NULL</code> if seeking is not implemented.
  external op_seek_func seek;

  /// Used to return the current read position in the stream.
  /// This may be <code>NULL</code> if seeking is not implemented.
  @ffi.Int()
  external int tell;

  /// Used to close the stream when the decoder is freed.
  /// This may be <code>NULL</code> to leave the stream open.
  external op_close_func close;
}

/// Reads up to \a _nbytes bytes of data from \a _stream.
/// \param      _stream The stream to read from.
/// \param[out] _ptr    The buffer to store the data in.
/// \param      _nbytes The maximum number of bytes to read.
/// This function may return fewer, though it will not
/// return zero unless it reaches end-of-file.
/// \return The number of bytes successfully read, or a negative value on
/// error.
typedef op_read_func = ffi.Pointer<ffi.NativeFunction<op_read_funcFunction>>;
typedef op_read_funcFunction = ffi.Int Function(ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<ffi.UnsignedChar> _ptr, ffi.Int _nbytes);
typedef Dartop_read_funcFunction = int Function(ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<ffi.UnsignedChar> _ptr, int _nbytes);

/// Sets the position indicator for \a _stream.
/// The new position, measured in bytes, is obtained by adding \a _offset
/// bytes to the position specified by \a _whence.
/// If \a _whence is set to <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or
/// <code>SEEK_END</code>, the offset is relative to the start of the stream,
/// the current position indicator, or end-of-file, respectively.
/// \retval 0  Success.
/// \retval -1 Seeking is not supported or an error occurred.
/// <code>errno</code> need not be set.
typedef op_seek_func = ffi.Pointer<ffi.NativeFunction<op_seek_funcFunction>>;
typedef op_seek_funcFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> _stream, ffi.Int _offset, ffi.Int _whence);
typedef Dartop_seek_funcFunction = int Function(
    ffi.Pointer<ffi.Void> _stream, int _offset, int _whence);

/// Closes the underlying stream.
/// \retval 0   Success.
/// \retval EOF An error occurred.
/// <code>errno</code> need not be set.
typedef op_close_func = ffi.Pointer<ffi.NativeFunction<op_close_funcFunction>>;
typedef op_close_funcFunction = ffi.Int Function(ffi.Pointer<ffi.Void> _stream);
typedef Dartop_close_funcFunction = int Function(ffi.Pointer<ffi.Void> _stream);

final class OggOpusFile extends ffi.Opaque {}

typedef NativeOpus_head_parse = ffi.Int Function(ffi.Pointer<OpusHead> _head,
    ffi.Pointer<ffi.UnsignedChar> _data, ffi.Size _len);
typedef DartOpus_head_parse = int Function(
    ffi.Pointer<OpusHead> _head, ffi.Pointer<ffi.UnsignedChar> _data, int _len);
typedef NativeOpus_granule_sample = ffi.Int Function(
    ffi.Pointer<OpusHead> _head, ffi.Int _gp);
typedef DartOpus_granule_sample = int Function(
    ffi.Pointer<OpusHead> _head, int _gp);
typedef NativeOpus_tags_parse = ffi.Int Function(ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.UnsignedChar> _data, ffi.Size _len);
typedef DartOpus_tags_parse = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.UnsignedChar> _data, int _len);
typedef NativeOpus_tags_copy = ffi.Int Function(
    ffi.Pointer<OpusTags> _dst, ffi.Pointer<OpusTags> _src);
typedef DartOpus_tags_copy = int Function(
    ffi.Pointer<OpusTags> _dst, ffi.Pointer<OpusTags> _src);
typedef NativeOpus_tags_init = ffi.Void Function(ffi.Pointer<OpusTags> _tags);
typedef DartOpus_tags_init = void Function(ffi.Pointer<OpusTags> _tags);
typedef NativeOpus_tags_add = ffi.Int Function(ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _tag, ffi.Pointer<ffi.Char> _value);
typedef DartOpus_tags_add = int Function(ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.Char> _tag, ffi.Pointer<ffi.Char> _value);
typedef NativeOpus_tags_add_comment = ffi.Int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _comment);
typedef DartOpus_tags_add_comment = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _comment);
typedef NativeOpus_tags_set_binary_suffix = ffi.Int Function(
    ffi.Pointer<OpusTags> _tags,
    ffi.Pointer<ffi.UnsignedChar> _data,
    ffi.Int _len);
typedef DartOpus_tags_set_binary_suffix = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.UnsignedChar> _data, int _len);
typedef NativeOpus_tags_query = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _tag, ffi.Int _count);
typedef DartOpus_tags_query = ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _tag, int _count);
typedef NativeOpus_tags_query_count = ffi.Int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _tag);
typedef DartOpus_tags_query_count = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Char> _tag);
typedef NativeOpus_tags_get_binary_suffix = ffi.Pointer<ffi.UnsignedChar>
    Function(ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _len);
typedef DartOpus_tags_get_binary_suffix = ffi.Pointer<ffi.UnsignedChar>
    Function(ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _len);
typedef NativeOpus_tags_get_album_gain = ffi.Int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _gain_q8);
typedef DartOpus_tags_get_album_gain = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _gain_q8);
typedef NativeOpus_tags_get_track_gain = ffi.Int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _gain_q8);
typedef DartOpus_tags_get_track_gain = int Function(
    ffi.Pointer<OpusTags> _tags, ffi.Pointer<ffi.Int> _gain_q8);
typedef NativeOpus_tags_clear = ffi.Void Function(ffi.Pointer<OpusTags> _tags);
typedef DartOpus_tags_clear = void Function(ffi.Pointer<OpusTags> _tags);
typedef NativeOpus_tagcompare = ffi.Int Function(
    ffi.Pointer<ffi.Char> _tag_name, ffi.Pointer<ffi.Char> _comment);
typedef DartOpus_tagcompare = int Function(
    ffi.Pointer<ffi.Char> _tag_name, ffi.Pointer<ffi.Char> _comment);
typedef NativeOpus_tagncompare = ffi.Int Function(
    ffi.Pointer<ffi.Char> _tag_name,
    ffi.Int _tag_len,
    ffi.Pointer<ffi.Char> _comment);
typedef DartOpus_tagncompare = int Function(ffi.Pointer<ffi.Char> _tag_name,
    int _tag_len, ffi.Pointer<ffi.Char> _comment);
typedef NativeOpus_picture_tag_parse = ffi.Int Function(
    ffi.Pointer<OpusPictureTag> _pic, ffi.Pointer<ffi.Char> _tag);
typedef DartOpus_picture_tag_parse = int Function(
    ffi.Pointer<OpusPictureTag> _pic, ffi.Pointer<ffi.Char> _tag);
typedef NativeOpus_picture_tag_init = ffi.Void Function(
    ffi.Pointer<OpusPictureTag> _pic);
typedef DartOpus_picture_tag_init = void Function(
    ffi.Pointer<OpusPictureTag> _pic);
typedef NativeOpus_picture_tag_clear = ffi.Void Function(
    ffi.Pointer<OpusPictureTag> _pic);
typedef DartOpus_picture_tag_clear = void Function(
    ffi.Pointer<OpusPictureTag> _pic);
typedef NativeOpus_server_info_init = ffi.Void Function(
    ffi.Pointer<OpusServerInfo> _info);
typedef DartOpus_server_info_init = void Function(
    ffi.Pointer<OpusServerInfo> _info);
typedef NativeOpus_server_info_clear = ffi.Void Function(
    ffi.Pointer<OpusServerInfo> _info);
typedef DartOpus_server_info_clear = void Function(
    ffi.Pointer<OpusServerInfo> _info);
typedef NativeOp_fopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode);
typedef DartOp_fopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode);
typedef NativeOp_fdopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Int _fd,
    ffi.Pointer<ffi.Char> _mode);
typedef DartOp_fdopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb, int _fd, ffi.Pointer<ffi.Char> _mode);
typedef NativeOp_freopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode,
    ffi.Pointer<ffi.Void> _stream);
typedef DartOp_freopen = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _path,
    ffi.Pointer<ffi.Char> _mode,
    ffi.Pointer<ffi.Void> _stream);
typedef NativeOp_mem_stream_create = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _data,
    ffi.Size _size);
typedef DartOp_mem_stream_create = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size);
typedef NativeOp_url_stream_vcreate = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _url,
    va_list _ap);
typedef DartOp_url_stream_vcreate = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.Char> _url,
    va_list _ap);
typedef NativeOp_url_stream_create = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb, ffi.Pointer<ffi.Char> _url);
typedef DartOp_url_stream_create = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<OpusFileCallbacks> _cb, ffi.Pointer<ffi.Char> _url);
typedef NativeOp_test = ffi.Int Function(ffi.Pointer<OpusHead> _head,
    ffi.Pointer<ffi.UnsignedChar> _initial_data, ffi.Size _initial_bytes);
typedef DartOp_test = int Function(ffi.Pointer<OpusHead> _head,
    ffi.Pointer<ffi.UnsignedChar> _initial_data, int _initial_bytes);
typedef NativeOp_open_file = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _path, ffi.Pointer<ffi.Int> _error);
typedef DartOp_open_file = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _path, ffi.Pointer<ffi.Int> _error);
typedef NativeOp_open_memory = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.UnsignedChar> _data,
    ffi.Size _size,
    ffi.Pointer<ffi.Int> _error);
typedef DartOp_open_memory = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size,
    ffi.Pointer<ffi.Int> _error);
typedef NativeOp_vopen_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error, va_list _ap);
typedef DartOp_vopen_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error, va_list _ap);
typedef NativeOp_open_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error);
typedef DartOp_open_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error);
typedef NativeOp_open_callbacks = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    ffi.Size _initial_bytes,
    ffi.Pointer<ffi.Int> _error);
typedef DartOp_open_callbacks = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    int _initial_bytes,
    ffi.Pointer<ffi.Int> _error);
typedef NativeOp_test_file = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _path, ffi.Pointer<ffi.Int> _error);
typedef DartOp_test_file = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _path, ffi.Pointer<ffi.Int> _error);
typedef NativeOp_test_memory = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.UnsignedChar> _data,
    ffi.Size _size,
    ffi.Pointer<ffi.Int> _error);
typedef DartOp_test_memory = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.UnsignedChar> _data,
    int _size,
    ffi.Pointer<ffi.Int> _error);
typedef NativeOp_vtest_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error, va_list _ap);
typedef DartOp_vtest_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error, va_list _ap);
typedef NativeOp_test_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error);
typedef DartOp_test_url = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Char> _url, ffi.Pointer<ffi.Int> _error);
typedef NativeOp_test_callbacks = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    ffi.Size _initial_bytes,
    ffi.Pointer<ffi.Int> _error);
typedef DartOp_test_callbacks = ffi.Pointer<OggOpusFile> Function(
    ffi.Pointer<ffi.Void> _stream,
    ffi.Pointer<OpusFileCallbacks> _cb,
    ffi.Pointer<ffi.UnsignedChar> _initial_data,
    int _initial_bytes,
    ffi.Pointer<ffi.Int> _error);
typedef NativeOp_test_open = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_test_open = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_free = ffi.Void Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_free = void Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_seekable = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_seekable = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_link_count = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_link_count = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_serialno = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_serialno = int Function(ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_channel_count = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_channel_count = int Function(
    ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_raw_total = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_raw_total = int Function(ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_pcm_total = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_pcm_total = int Function(ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_head = ffi.Pointer<OpusHead> Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_head = ffi.Pointer<OpusHead> Function(
    ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_tags = ffi.Pointer<OpusTags> Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_tags = ffi.Pointer<OpusTags> Function(
    ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_current_link = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_current_link = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_bitrate = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _li);
typedef DartOp_bitrate = int Function(ffi.Pointer<OggOpusFile> _of, int _li);
typedef NativeOp_bitrate_instant = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of);
typedef DartOp_bitrate_instant = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_raw_tell = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_raw_tell = int Function(ffi.Pointer<OggOpusFile> _of);
typedef NativeOp_pcm_tell = ffi.Int Function(ffi.Pointer<OggOpusFile> _of);
typedef DartOp_pcm_tell = int Function(ffi.Pointer<OggOpusFile> _of);

/// Obtains the current value of the position indicator for \a _stream.
/// \return The current position indicator.
typedef opus_int64 = ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>;
typedef NativeOp_raw_seek = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Pointer<opus_int64> _byte_offset);
typedef DartOp_raw_seek = int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Pointer<opus_int64> _byte_offset);
typedef NativeOp_pcm_seek = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _pcm_offset);
typedef DartOp_pcm_seek = int Function(
    ffi.Pointer<OggOpusFile> _of, int _pcm_offset);

/// Called to decode an Opus packet.
/// This should invoke the functional equivalent of opus_multistream_decode() or
/// opus_multistream_decode_float(), except that it returns 0 on success
/// instead of the number of decoded samples (which is known a priori).
/// \param _ctx       The application-provided callback context.
/// \param _decoder   The decoder to use to decode the packet.
/// \param[out] _pcm  The buffer to decode into.
/// This will always have enough room for \a _nchannels of
/// \a _nsamples samples, which should be placed into this
/// buffer interleaved.
/// \param _op        The packet to decode.
/// This will always have its granule position set to a valid
/// value.
/// \param _nsamples  The number of samples expected from the packet.
/// \param _nchannels The number of channels expected from the packet.
/// \param _format    The desired sample output format.
/// This is either #OP_DEC_FORMAT_SHORT or
/// #OP_DEC_FORMAT_FLOAT.
/// \param _li        The index of the link from which this packet was decoded.
/// \return A non-negative value on success, or a negative value on error.
/// Any error codes should be the same as those returned by
/// opus_multistream_decode() or opus_multistream_decode_float().
/// Success codes are as follows:
/// \retval 0                   Decoding was successful.
/// The application has filled the buffer with
/// exactly <code>\a _nsamples*\a
/// _nchannels</code> samples in the requested
/// format.
/// \retval #OP_DEC_USE_DEFAULT No decoding was done.
/// <tt>libopusfile</tt> should do the decoding
/// by itself instead.
typedef op_decode_cb_func
    = ffi.Pointer<ffi.NativeFunction<op_decode_cb_funcFunction>>;
typedef op_decode_cb_funcFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> _ctx,
    ffi.Pointer<ffi.Int> _decoder,
    ffi.Pointer<ffi.Void> _pcm,
    ffi.Pointer<ffi.Int> _op,
    ffi.Int _nsamples,
    ffi.Int _nchannels,
    ffi.Int _format,
    ffi.Int _li);
typedef Dartop_decode_cb_funcFunction = int Function(
    ffi.Pointer<ffi.Void> _ctx,
    ffi.Pointer<ffi.Int> _decoder,
    ffi.Pointer<ffi.Void> _pcm,
    ffi.Pointer<ffi.Int> _op,
    int _nsamples,
    int _nchannels,
    int _format,
    int _li);
typedef NativeOp_set_decode_callback = ffi.Void Function(
    ffi.Pointer<OggOpusFile> _of,
    op_decode_cb_func _decode_cb,
    ffi.Pointer<ffi.Void> _ctx);
typedef DartOp_set_decode_callback = void Function(ffi.Pointer<OggOpusFile> _of,
    op_decode_cb_func _decode_cb, ffi.Pointer<ffi.Void> _ctx);
typedef NativeOp_set_gain_offset = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _gain_type, ffi.Int _gain_offset_q8);
typedef DartOp_set_gain_offset = int Function(
    ffi.Pointer<OggOpusFile> _of, int _gain_type, int _gain_offset_q8);
typedef NativeOp_set_dither_enabled = ffi.Void Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Int _enabled);
typedef DartOp_set_dither_enabled = void Function(
    ffi.Pointer<OggOpusFile> _of, int _enabled);
typedef NativeOp_read = ffi.Int Function(ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Int> _pcm, ffi.Int _buf_size, ffi.Pointer<ffi.Int> _li);
typedef DartOp_read = int Function(ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Int> _pcm, int _buf_size, ffi.Pointer<ffi.Int> _li);
typedef NativeOp_read_float = ffi.Int Function(ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Float> _pcm, ffi.Int _buf_size, ffi.Pointer<ffi.Int> _li);
typedef DartOp_read_float = int Function(ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Float> _pcm, int _buf_size, ffi.Pointer<ffi.Int> _li);
typedef NativeOp_read_stereo = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Pointer<ffi.Int> _pcm, ffi.Int _buf_size);
typedef DartOp_read_stereo = int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Pointer<ffi.Int> _pcm, int _buf_size);
typedef NativeOp_read_float_stereo = ffi.Int Function(
    ffi.Pointer<OggOpusFile> _of,
    ffi.Pointer<ffi.Float> _pcm,
    ffi.Int _buf_size);
typedef DartOp_read_float_stereo = int Function(
    ffi.Pointer<OggOpusFile> _of, ffi.Pointer<ffi.Float> _pcm, int _buf_size);

const int _opusfile_h = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 'C';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const String _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = '';

const int _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1;

const int _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2;

const int _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4;

const int _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8;

const int _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16;

const int _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32;

const int _CRT_INTERNAL_SCANF_SECURECRT = 1;

const int _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2;

const int _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4;

const int WEOF = 65535;

const int BUFSIZ = 512;

const int _NFILE = 512;

const int _NSTREAM_ = 512;

const int _IOB_ENTRIES = 3;

const int EOF = -1;

const int _IOFBF = 0;

const int _IOLBF = 64;

const int _IONBF = 4;

const int L_tmpnam = 260;

const int L_tmpnam_s = 260;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_SET = 0;

const int FILENAME_MAX = 260;

const int FOPEN_MAX = 20;

const int _SYS_OPEN = 20;

const int TMP_MAX = 2147483647;

const int TMP_MAX_S = 2147483647;

const int _TMP_MAX_S = 2147483647;

const int SYS_OPEN = 20;

const int OP_FALSE = -1;

const int OP_EOF = -2;

const int OP_HOLE = -3;

const int OP_EREAD = -128;

const int OP_EFAULT = -129;

const int OP_EIMPL = -130;

const int OP_EINVAL = -131;

const int OP_ENOTFORMAT = -132;

const int OP_EBADHEADER = -133;

const int OP_EVERSION = -134;

const int OP_ENOTAUDIO = -135;

const int OP_EBADPACKET = -136;

const int OP_EBADLINK = -137;

const int OP_ENOSEEK = -138;

const int OP_EBADTIMESTAMP = -139;

const int OPUS_CHANNEL_COUNT_MAX = 255;

const int OP_PIC_FORMAT_UNKNOWN = -1;

const int OP_PIC_FORMAT_URL = 0;

const int OP_PIC_FORMAT_JPEG = 1;

const int OP_PIC_FORMAT_PNG = 2;

const int OP_PIC_FORMAT_GIF = 3;

const int OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST = 6464;

const int OP_HTTP_PROXY_HOST_REQUEST = 6528;

const int OP_HTTP_PROXY_PORT_REQUEST = 6592;

const int OP_HTTP_PROXY_USER_REQUEST = 6656;

const int OP_HTTP_PROXY_PASS_REQUEST = 6720;

const int OP_GET_SERVER_INFO_REQUEST = 6784;

const int OP_DEC_FORMAT_SHORT = 7008;

const int OP_DEC_FORMAT_FLOAT = 7040;

const int OP_DEC_USE_DEFAULT = 6720;

const int OP_HEADER_GAIN = 0;

const int OP_ALBUM_GAIN = 3007;

const int OP_TRACK_GAIN = 3008;

const int OP_ABSOLUTE_GAIN = 3009;
